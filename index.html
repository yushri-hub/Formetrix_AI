<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="AI Formatter Pro - Smart text processing with OCR and AI formatting">
  <meta name="theme-color" content="#2563eb">
  <title>AI Formatter Pro ‚Äì Smart Text Processing</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- Preload critical resources -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Tesseract and PDF.js -->
  <script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

  <link rel="stylesheet" href="styles.css">
  <STYle>
    /* ========================================
   CSS Custom Properties - Enhanced with Dark Mode
   ======================================== */
    :root {
      /* Brand Colors - Improved contrast and accessibility */
      --brand-primary: #2563eb;
      --brand-primary-hover: #1d4ed8;
      --brand-primary-light: rgba(37, 99, 235, 0.08);
      --brand-primary-very-light: rgba(37, 99, 235, 0.02);
      --brand-primary-rgb: 37, 99, 235;

      /* Neutrals - Better hierarchy */
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;

      /* Text - WCAG AA compliant */
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --text-on-primary: #ffffff;

      /* Borders */
      --border-light: #e2e8f0;
      --border-medium: #cbd5e1;
      --border-dark: #94a3b8;

      /* Status colors - Enhanced contrast */
      --success: #059669;
      --success-bg: #d1fae5;
      --success-text: #065f46;
      --warning: #d97706;
      --warning-bg: #fef3c7;
      --warning-text: #92400e;
      --error: #dc2626;
      --error-bg: #fee2e2;
      --error-text: #991b1b;
      --info: #2563eb;
      --info-bg: #dbeafe;
      --info-text: #1e40af;

      /* Spacing scale */
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 12px;
      --space-lg: 16px;
      --space-xl: 24px;
      --space-2xl: 32px;
      --space-3xl: 48px;

      /* Border radius scale */
      --radius-sm: 6px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;

      /* Shadows - Refined hierarchy */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.1), 0 10px 10px rgba(0, 0, 0, 0.04);

      /* Input styles */
      --input-bg: #ffffff;
      --input-border: var(--border-light);
      --input-text: var(--text-primary);
      --input-focus: var(--brand-primary);
      --input-focus-ring: 0 0 0 3px rgba(var(--brand-primary-rgb), 0.1);

      /* Surface elevation */
      --surface: #ffffff;
      --surface-elevated: #fafbfc;

      /* Animation */
      --transition-fast: 0.15s ease;
      --transition-normal: 0.3s ease;
      --transition-slow: 0.5s ease;

      /* Z-index scale */
      --z-dropdown: 1000;
      --z-modal: 2000;
      --z-toast: 3000;
    }

    /* Dark theme */
    [data-theme="dark"] {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      
      --text-primary: #f1f5f9;
      --text-secondary: #cbd5e1;
      --text-muted: #94a3b8;
      
      --border-light: #334155;
      --border-medium: #475569;
      --border-dark: #64748b;
      
      --input-bg: #1e293b;
      --input-border: var(--border-light);
      --input-text: var(--text-primary);
      
      --surface: #1e293b;
      --surface-elevated: #334155;
      
      --success-bg: #065f46;
      --warning-bg: #92400e;
      --error-bg: #991b1b;
      --info-bg: #1e40af;
      
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow: 0 1px 3px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4), 0 4px 6px rgba(0, 0, 0, 0.3);
      --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.4), 0 10px 10px rgba(0, 0, 0, 0.3);
    }

    /* ========================================
      Reset and Base Styles
      ======================================== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background-color var(--transition-normal), color var(--transition-normal);
    }

    body {
      padding: var(--space-lg);
      max-width: 1600px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ========================================
      Typography
      ======================================== */
    h1, h2, h3, h4, h5, h6 {
      font-weight: 600;
      line-height: 1.3;
      margin-bottom: var(--space-md);
    }

    h1 {
      font-size: 24px;
      font-weight: 700;
    }

    h2 {
      font-size: 20px;
    }

    h3 {
      font-size: 18px;
    }

    p {
      margin-bottom: var(--space-md);
    }

    /* ========================================
      Header
      ======================================== */
    header {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      margin-bottom: var(--space-lg);
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-lg);
      flex-wrap: wrap;
      position: relative;
      transition: all var(--transition-normal);
    }

    .header-left h1 {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: var(--space-xs);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .header-left p {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 0;
    }

    .header-right {
      display: flex;
      gap: var(--space-md);
      align-items: center;
      flex-wrap: wrap;
    }

    /* Theme Toggle */
    .theme-toggle {
      background: none;
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: 8px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 36px;
      min-width: 36px;
    }

    .theme-toggle:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* ========================================
      Buttons - Enhanced Hierarchy
      ======================================== */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: all var(--transition-fast);
      white-space: nowrap;
      position: relative;
      text-decoration: none;
      min-height: 44px;
      justify-content: center;
    }

    .btn:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    /* Primary Button */
    .btn-primary {
      background: var(--brand-primary);
      color: var(--text-on-primary);
      box-shadow: var(--shadow-sm);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--brand-primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-primary:active:not(:disabled) {
      transform: translateY(0);
    }

    /* Secondary Button */
    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-light);
    }

    .btn-secondary:hover:not(:disabled) {
      background: var(--border-light);
      border-color: var(--border-medium);
      transform: translateY(-1px);
    }

    /* Text Button */
    .btn-text {
      background: transparent;
      color: var(--text-secondary);
      padding: 8px 12px;
      min-height: auto;
    }

    .btn-text:hover:not(:disabled) {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* Header Buttons */
    .header-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      min-height: 36px;
    }

    .header-btn:hover {
      background: var(--border-light);
      border-color: var(--border-medium);
      transform: translateY(-1px);
    }

    .header-btn .material-icons {
      font-size: 18px;
    }

    /* Button Sizes */
    .btn-sm {
      padding: 6px 12px;
      font-size: 13px;
      min-height: 32px;
    }

    .btn-lg {
      padding: 12px 20px;
      font-size: 16px;
      min-height: 48px;
    }

    .btn-process {
      width: 100%;
      justify-content: center;
      margin-top: var(--space-md);
      padding: 12px 20px;
      font-size: 15px;
      min-height: 48px;
    }

    /* ========================================
      Main Layout
      ======================================== */
    .app {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-lg);
      min-height: calc(100vh - 200px);
      flex: 1;
    }

    .panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    /* ========================================
      Section Cards
      ======================================== */
    .section-card {
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow);
      border: 1px solid var(--border-light);
      transition: all var(--transition-normal);
    }

    .section-card:hover {
      box-shadow: var(--shadow-md);
    }

    .section-card-full {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 600px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-light);
    }

    .section-header h3 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .section-header .material-icons {
      color: var(--brand-primary);
      font-size: 22px;
    }

    .section-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
    }

    /* ========================================
      Combined Text Input with File Upload
      ======================================== */
    .combined-input-container {
      margin-bottom: var(--space-lg);
    }

    .text-input-with-upload {
      position: relative;
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--surface);
      transition: all var(--transition-normal);
      overflow: hidden;
    }

    .text-input-with-upload:hover {
      border-color: var(--border-medium);
    }

    .text-input-with-upload.drag-over {
      border-color: var(--brand-primary);
      background: var(--brand-primary-very-light);
      box-shadow: var(--input-focus-ring);
    }

    #textInput {
      width: 100%;
      min-height: 120px;
      max-height: 300px;
      padding: var(--space-md);
      padding-right: 50px;
      border: none;
      border-radius: var(--radius-md);
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      line-height: 1.6;
      resize: vertical;
      transition: all var(--transition-fast);
      overflow-y: auto;
    }

    #textInput:focus {
      outline: none;
      background: var(--bg-secondary);
    }

    #textInput::placeholder {
      color: var(--text-muted);
      font-style: italic;
    }

    .upload-icon-btn {
      position: absolute;
      bottom: var(--space-sm);
      right: var(--space-sm);
      width: 36px;
      height: 36px;
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
      z-index: 10;
      min-height: auto;
    }

    .upload-icon-btn:hover {
      background: var(--brand-primary);
      border-color: var(--brand-primary);
      color: var(--text-on-primary);
      transform: scale(1.1);
    }

    .upload-icon-btn .material-icons {
      font-size: 20px;
    }

    #fileInput {
      display: none;
    }

    /* File upload preview */
    .file-preview {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .file-preview-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      font-size: 13px;
      max-width: 200px;
    }

    .file-preview-item .material-icons {
      font-size: 16px;
      color: var(--text-muted);
    }

    .file-preview-remove {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .file-preview-remove:hover {
      background: var(--error-bg);
      color: var(--error);
    }

    /* ========================================
      Form Elements
      ======================================== */
    textarea,
    input[type="text"],
    input[type="password"],
    input[type="url"],
    select {
      width: 100%;
      padding: var(--space-md);
      border: 1px solid var(--input-border);
      border-radius: var(--radius-md);
      background: var(--input-bg);
      color: var(--input-text);
      font-size: 14px;
      font-family: inherit;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
      min-height: 44px;
    }

    textarea {
      resize: vertical;
      min-height: 50px;
      line-height: 1.6;
    }

    textarea:focus,
    input:focus,
    select:focus {
      outline: none;
      border-color: var(--input-focus);
      box-shadow: var(--input-focus-ring);
    }

    /* ========================================
      Document Cards
      ======================================== */
    .document-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .document-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-md);
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      min-height: 60px;
      position: relative;
    }

    .document-card:hover {
      border-color: var(--border-medium);
      box-shadow: var(--shadow-sm);
      transform: translateY(-1px);
    }

    .document-card.active {
      border-color: var(--brand-primary);
      background: var(--brand-primary-light);
      box-shadow: var(--shadow-md);
    }

    .document-card.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }

    .document-card-actions {
      display: flex;
      gap: var(--space-xs);
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .document-card:hover .document-card-actions {
      opacity: 1;
    }

    .doc-info {
      flex: 1;
      min-width: 0;
    }

    .doc-name {
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .doc-meta {
      font-size: 12px;
      color: var(--text-muted);
    }

    .empty-state {
      text-align: center;
      padding: var(--space-xl);
      color: var(--text-muted);
      font-style: italic;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-md);
    }

    .empty-state .material-icons {
      font-size: 48px;
      opacity: 0.5;
    }

    /* ========================================
      Status Elements
      ======================================== */
    .status-pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      border: 1px solid transparent;
    }

    .status-uploaded {
      background: var(--info-bg);
      color: var(--info-text);
      border-color: var(--info);
    }

    .status-processing {
      background: var(--warning-bg);
      color: var(--warning-text);
      border-color: var(--warning);
    }

    .status-ready {
      background: var(--success-bg);
      color: var(--success-text);
      border-color: var(--success);
    }

    .status-error {
      background: var(--error-bg);
      color: var(--error-text);
      border-color: var(--error);
    }

    /* ========================================
      Progress Bar
      ======================================== */
    .progress-container-wide {
      width: 100%;
      margin-bottom: var(--space-lg);
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-sm);
    }

    .progress-label {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .progress-wide {
      width: 100%;
      height: 12px;
      background: var(--bg-tertiary);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill-wide {
      height: 100%;
      background: var(--brand-primary);
      border-radius: 999px;
      transition: width var(--transition-normal) ease;
      width: 0;
      position: relative;
      overflow: hidden;
    }

    .progress-fill-wide::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.4),
        transparent
      );
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% {
        left: -100%;
      }
      100% {
        left: 100%;
      }
    }

    /* ========================================
      Prompt Chips
      ======================================== */
    .prompt-chips {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .prompt-chip {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      font-size: 13px;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      min-height: 32px;
    }

    .prompt-chip:hover {
      border-color: var(--brand-primary);
      background: var(--brand-primary-light);
      color: var(--brand-primary);
    }

    .prompt-chip.active {
      background: var(--brand-primary);
      color: var(--text-on-primary);
      border-color: var(--brand-primary);
    }

    /* ========================================
      Output Area
      ======================================== */
    #outputText {
      width: 100%;
      flex: 1;
      min-height: 400px;
      padding: var(--space-md);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--input-bg);
      color: var(--input-text);
      font-size: 14px;
      font-family: inherit;
      line-height: 1.6;
      resize: vertical;
      transition: all var(--transition-fast);
    }

    #outputText:focus {
      outline: none;
      border-color: var(--input-focus);
      box-shadow: var(--input-focus-ring);
    }

    .output-actions {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
      margin-top: var(--space-md);
    }

    /* Output Format Preview */
    .output-preview {
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      background: var(--surface);
      margin-top: var(--space-md);
      overflow: hidden;
    }

    .preview-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-light);
      background: var(--bg-tertiary);
    }

    .preview-tab {
      padding: var(--space-md) var(--space-lg);
      background: none;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      transition: all var(--transition-fast);
    }

    .preview-tab.active {
      color: var(--brand-primary);
      border-bottom-color: var(--brand-primary);
      background: var(--surface);
    }

    .preview-content {
      padding: var(--space-md);
      max-height: 200px;
      overflow-y: auto;
    }

    .preview-content pre {
      margin: 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }

    /* ========================================
      Modals
      ======================================== */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: var(--z-modal);
      align-items: center;
      justify-content: center;
      padding: var(--space-lg);
    }

    .modal.active {
      display: flex;
      animation: modalFadeIn var(--transition-normal);
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        backdrop-filter: blur(0px);
      }
      to {
        opacity: 1;
        backdrop-filter: blur(4px);
      }
    }

    .modal-content {
      background: var(--surface);
      border-radius: var(--radius-xl);
      padding: var(--space-2xl);
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      animation: modalSlideIn var(--transition-normal) ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.95) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xl);
    }

    .modal-header h3 {
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 28px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      min-height: auto;
    }

    .modal-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* ========================================
      Help Modal Styles
      ======================================== */
    .help-step {
      margin-bottom: var(--space-xl);
      padding: var(--space-lg);
      background: var(--bg-secondary);
      border-left: 4px solid var(--brand-primary);
      border-radius: var(--radius-md);
    }

    .help-step-header {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      margin-bottom: var(--space-md);
    }

    .step-number {
      background: var(--brand-primary);
      color: var(--text-on-primary);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      flex-shrink: 0;
    }

    .help-step h4 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .help-step p {
      margin: 0 0 var(--space-sm) 44px;
    }

    .help-step ul,
    .help-step ol {
      margin: 0 0 0 44px;
      padding-left: var(--space-lg);
      font-size: 13px;
      line-height: 1.8;
    }

    .help-step li {
      margin-bottom: var(--space-sm);
    }

    .api-option {
      background: var(--surface);
      border: 2px solid var(--brand-primary);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      margin: var(--space-md) 0 var(--space-md) 44px;
    }

    .api-option-header {
      font-weight: 600;
      color: var(--brand-primary);
      margin-bottom: var(--space-sm);
      font-size: 14px;
    }

    .alternative-option {
      cursor: pointer;
      font-weight: 600;
      color: var(--brand-primary);
      padding: var(--space-sm);
      background: var(--brand-primary-light);
      border-radius: var(--radius-sm);
      margin: var(--space-md) 0 0 44px;
      display: block;
      border: none;
      width: calc(100% - 44px);
      text-align: left;
      transition: all var(--transition-fast);
    }

    .alternative-option:hover {
      background: var(--brand-primary);
      color: var(--text-on-primary);
    }

    .alternative-content {
      padding: var(--space-md);
      font-size: 13px;
      line-height: 1.6;
      margin-top: var(--space-sm);
      margin-left: 44px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
    }

    /* ========================================
      Info Boxes
      ======================================== */
    .info-box {
      padding: var(--space-md);
      border-radius: var(--radius-md);
      border-left: 3px solid;
      font-size: 13px;
      line-height: 1.6;
      margin: var(--space-md) 0 0 44px;
    }

    .info-box-info {
      background: var(--info-bg);
      border-color: var(--info);
      color: var(--text-primary);
    }

    .info-box-warning {
      background: var(--warning-bg);
      border-color: var(--warning);
      color: var(--text-primary);
    }

    .info-box-success {
      background: var(--success-bg);
      border-color: var(--success);
      color: var(--text-primary);
    }

    /* ========================================
      Notification Toast
      ======================================== */
    .toast {
      position: fixed;
      top: var(--space-xl);
      right: var(--space-xl);
      background: var(--surface);
      padding: var(--space-lg);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: var(--space-md);
      min-width: 300px;
      max-width: 400px;
      z-index: var(--z-toast);
      animation: toastSlideIn var(--transition-normal) ease;
      border-left: 4px solid;
      transform: translateX(0);
    }

    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .toast.toast-exit {
      animation: toastSlideOut var(--transition-normal) ease;
    }

    @keyframes toastSlideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }

    .toast-success {
      border-color: var(--success);
    }

    .toast-error {
      border-color: var(--error);
    }

    .toast-warning {
      border-color: var(--warning);
    }

    .toast-info {
      border-color: var(--info);
    }

    .toast-icon {
      font-size: 24px;
      flex-shrink: 0;
    }

    .toast-success .toast-icon {
      color: var(--success);
    }

    .toast-error .toast-icon {
      color: var(--error);
    }

    .toast-warning .toast-icon {
      color: var(--warning);
    }

    .toast-info .toast-icon {
      color: var(--info);
    }

    .toast-content {
      flex: 1;
      min-width: 0;
    }

    .toast-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .toast-message {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .toast-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: var(--space-xs);
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      min-height: auto;
      flex-shrink: 0;
    }

    .toast-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* ========================================
      Loading States
      ======================================== */
    .loading {
      opacity: 0.7;
      pointer-events: none;
      position: relative;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.6),
        transparent
      );
      animation: loadingShimmer 1.5s infinite;
    }

    @keyframes loadingShimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }

    /* ========================================
      Loading Spinner
      ======================================== */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--border-light);
      border-top-color: var(--brand-primary);
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      flex-shrink: 0;
    }

    .spinner-lg {
      width: 24px;
      height: 24px;
      border-width: 3px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* ========================================
      Confetti Animation
      ======================================== */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background: var(--brand-primary);
      top: 0;
      opacity: 0;
      z-index: var(--z-toast);
    }

    @keyframes confettiFall {
      0% {
        opacity: 1;
        transform: translateY(0) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: translateY(100vh) rotate(360deg);
      }
    }

    /* ========================================
      Keyboard Shortcuts Panel
      ======================================== */
    .shortcuts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-md);
      margin-top: var(--space-lg);
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-md);
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
    }

    .shortcut-keys {
      display: flex;
      gap: var(--space-xs);
    }

    .shortcut-key {
      padding: 2px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-family: monospace;
      min-width: 20px;
      text-align: center;
    }

    /* ========================================
      Template Library
      ======================================== */
    .template-categories {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
    }

    .template-category {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      font-size: 13px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .template-category.active {
      background: var(--brand-primary);
      color: var(--text-on-primary);
      border-color: var(--brand-primary);
    }

    .templates-grid {
      display: grid;
      gap: var(--space-md);
      max-height: 400px;
      overflow-y: auto;
    }

    .template-card {
      padding: var(--space-lg);
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .template-card:hover {
      border-color: var(--brand-primary);
      transform: translateY(-2px);
    }

    .template-card h4 {
      margin: 0 0 var(--space-sm) 0;
      color: var(--text-primary);
    }

    .template-card p {
      margin: 0;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .template-card .template-preview {
      margin-top: var(--space-md);
      padding: var(--space-md);
      background: var(--surface);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-muted);
      font-style: italic;
    }

    /* ========================================
      Batch Processing
      ======================================== */
    .batch-actions {
      display: flex;
      gap: var(--space-sm);
      margin-top: var(--space-md);
      flex-wrap: wrap;
    }

    .batch-progress {
      margin-top: var(--space-lg);
    }

    .batch-item {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-md);
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-sm);
    }

    .batch-item-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .batch-item-status.ready {
      background: var(--success);
    }

    .batch-item-status.processing {
      background: var(--warning);
    }

    .batch-item-status.error {
      background: var(--error);
    }

    /* ========================================
      Enhanced Tooltips
      ======================================== */
    .tooltip {
      position: relative;
    }

    .tooltip::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: var(--space-sm) var(--space-md);
      background: var(--text-primary);
      color: var(--text-on-primary);
      font-size: 12px;
      border-radius: var(--radius-sm);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-fast);
      z-index: var(--z-tooltip);
    }

    .tooltip:hover::before {
      opacity: 1;
    }

    /* ========================================
      Responsive Design
      ======================================== */
    @media (max-width: 1024px) {
      .app {
        grid-template-columns: 1fr;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .header-right {
        width: 100%;
        justify-content: flex-start;
      }
      
      .shortcuts-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .app {
        gap: var(--space-md);
      }
      
      .section-card {
        padding: var(--space-lg);
      }
      
      .output-actions {
        flex-direction: column;
      }
      
      .output-actions .btn {
        width: 100%;
        justify-content: center;
      }
      
      .batch-actions {
        flex-direction: column;
      }
      
      .template-categories {
        flex-direction: column;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: var(--space-sm);
      }

      header {
        padding: var(--space-lg);
      }

      .section-card {
        padding: var(--space-lg);
      }

      .btn-primary,
      .btn-secondary {
        padding: 8px 12px;
        font-size: 13px;
      }

      .modal-content {
        padding: var(--space-lg);
        margin: var(--space-sm);
      }

      .help-step p,
      .help-step ul,
      .help-step ol,
      .info-box,
      .api-option,
      .alternative-option,
      .alternative-content {
        margin-left: 0;
      }
      
      .toast {
        right: var(--space-sm);
        left: var(--space-sm);
        min-width: auto;
        max-width: none;
      }
      
      /* Mobile text areas */
      textarea {
        min-height: 200px;
      }
      
      #textInput {
        min-height: 150px;
      }
      
      #outputText {
        min-height: 300px;
      }
      
      .file-preview {
        flex-direction: column;
      }
      
      .file-preview-item {
        max-width: none;
      }
    }

    /* ========================================
      Accessibility Improvements
      ======================================== */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      margin: -1px;
      padding: 0;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    /* Focus styles for keyboard navigation */
    *:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
      :root {
        --border-light: #000000;
        --border-medium: #000000;
        --text-muted: #000000;
      }
      
      .section-card {
        border: 2px solid var(--border-light);
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ========================================
      Print styles
      ======================================== */
    @media print {
      header,
      .btn-primary,
      .btn-secondary,
      .upload-icon-btn {
        display: none;
      }
      
      .app {
        grid-template-columns: 1fr;
        gap: 0;
      }
      
      .section-card {
        box-shadow: none;
        border: 1px solid #000;
        break-inside: avoid;
      }
    }

    /* Add these styles to your existing CSS */

    /* Enhanced file processing states */
    .file-processing {
      border-left: 4px solid var(--brand-primary);
      background: var(--brand-primary-very-light);
    }

    .file-processing .file-preview-item {
      background: var(--brand-primary-light);
      border-color: var(--brand-primary);
    }

    .file-success .file-preview-item {
      background: var(--success-bg);
      border-color: var(--success);
    }

    .file-error .file-preview-item {
      background: var(--error-bg);
      border-color: var(--error);
    }

    /* Processing animation for file preview */
    .file-preview-item.processing {
      position: relative;
      overflow: hidden;
    }

    .file-preview-item.processing::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.6),
        transparent
      );
      animation: processingShimmer 1.5s infinite;
    }

    @keyframes processingShimmer {
      0% {
        left: -100%;
      }
      100% {
        left: 100%;
      }
    }

    /* File type icons */
    .file-type-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      border-radius: 2px;
      background: var(--brand-primary);
      color: white;
    }

    .file-type-pdf {
      background: #e74c3c;
    }

    .file-type-image {
      background: #9b59b6;
    }

    .file-type-text {
      background: #3498db;
    }

    /* Enhanced progress indicators */
    .processing-step {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-sm);
      font-size: 13px;
    }

    .processing-step.active {
      background: var(--brand-primary-light);
      border-left: 3px solid var(--brand-primary);
    }

    .processing-step.completed {
      background: var(--success-bg);
      border-left: 3px solid var(--success);
    }

    .step-indicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      background: var(--border-light);
      color: var(--text-muted);
    }

    .processing-step.active .step-indicator {
      background: var(--brand-primary);
      color: white;
    }

    .processing-step.completed .step-indicator {
      background: var(--success);
      color: white;
    }

    textarea::-webkit-resizer {
      /* Hides the resize handle */
      display: none;
    }
    /* Add to your existing CSS */
    .chat-message {
        padding: var(--space-md);
        border-radius: var(--radius-lg);
        max-width: 85%;
        word-wrap: break-word;
    }

    .user-message {
        align-self: flex-end;
        background: var(--brand-primary);
        color: var(--text-on-primary);
        border-bottom-right-radius: var(--radius-sm);
    }

    .ai-message {
        align-self: flex-start;
        background: var(--surface);
        border: 1px solid var(--border-light);
        border-bottom-left-radius: var(--radius-sm);
    }

    .message-content {
        margin-bottom: var(--space-xs);
        line-height: 1.5;
    }

    .message-time {
        font-size: 11px;
        opacity: 0.7;
        text-align: right;
    }

    .user-message .message-time {
        text-align: left;
    }

    #chatMessages::-webkit-scrollbar {
        width: 6px;
    }

    #chatMessages::-webkit-scrollbar-track {
        background: var(--bg-tertiary);
        border-radius: 3px;
    }

    #chatMessages::-webkit-scrollbar-thumb {
        background: var(--border-medium);
        border-radius: 3px;
    }

    #chatMessages::-webkit-scrollbar-thumb:hover {
        background: var(--border-dark);
    }

    .chat-thinking {
        opacity: 0.7;
        font-style: italic;
    }

  </STYle>
</head>

<body>
  <header>
    <div class="header-left">
      <h1>ü§ñ AI Formatter Pro</h1>
      <p>Smart text processing with OCR and AI formatting</p>
    </div>
    <div class="header-right">
      <!-- In the header-right section, add this button -->
      <button class="header-btn" id="chatBtn" title="Chat with AI" aria-label="Open AI chat">
        <span class="material-icons" aria-hidden="true">chat</span>
        Chat
      </button>
      <button class="header-btn" id="helpBtn" title="Help Guide" aria-label="Open help guide">
        <span class="material-icons" aria-hidden="true">help_outline</span>
        Help
      </button>
      <button class="header-btn" id="settingsBtn" title="AI Settings" aria-label="Open AI settings">
        <span class="material-icons" aria-hidden="true">settings</span>
        Settings
      </button>
      <button class="header-btn" id="shortcutsBtn" title="Keyboard Shortcuts" aria-label="View keyboard shortcuts">
        <span class="material-icons" aria-hidden="true">keyboard</span>
        Shortcuts
      </button>
      <button class="header-btn" id="templatesBtn" title="Template Library" aria-label="Browse prompt templates">
        <span class="material-icons" aria-hidden="true">library_books</span>
        Templates
      </button>
      <button class="header-btn" id="exportBtn" title="Export Results" aria-label="Export results">
        <span class="material-icons" aria-hidden="true">download</span>
        Export
      </button>
      <button class="theme-toggle" id="themeToggle" title="Toggle theme" aria-label="Toggle dark/light theme">
        <span class="material-icons" id="themeIcon">dark_mode</span>
      </button>
    </div>
  </header>

  <main class="app">
    <!-- Left Panel: Input -->
    <section class="panel" aria-labelledby="input-panel-title">
      <!-- Replace the Document Input Section Card in your HTML with this improved version -->
      
      <!-- Document Input Section Card -->
      <div class="section-card">
        <div class="section-header">
          <span class="material-icons" aria-hidden="true">description</span>
          <h3 id="input-panel-title">Document Input</h3>
        </div>
      
        <!-- Combined Text Input with File Upload -->
        <div class="combined-input-container">
          <label for="textInput" class="section-label">Enter text or upload files</label>
          <div class="text-input-with-upload" role="region" aria-label="Text input and file upload area">
            <textarea id="textInput"
              placeholder="Paste your text here or drag & drop files (PDF, Images, Text files supported)..."
              aria-label="Text input area" rows="1"></textarea>
            <button class="upload-icon-btn" id="uploadIconBtn" title="Upload files (PDF, Images, Text)"
              aria-label="Upload files">
              <span class="material-icons" aria-hidden="true">add</span>
            </button>
            <input type="file" id="fileInput" accept=".pdf,.jpg,.jpeg,.png,.tiff,.txt,.doc,.docx" multiple
              aria-label="File upload input">
          </div>
      
          <!-- File Preview with Processing Status -->
          <div class="file-preview" id="filePreview" style="display: none;"></div>
      
          <!-- Processing Steps -->
          <div id="processingSteps" style="display: none; margin-top: var(--space-md);">
            <div class="section-label">Processing Steps</div>
            <div class="processing-step" id="stepUpload">
              <div class="step-indicator">1</div>
              <span>File uploaded</span>
            </div>
            <div class="processing-step" id="stepExtract">
              <div class="step-indicator">2</div>
              <span>Extracting text...</span>
            </div>
            <div class="processing-step" id="stepComplete">
              <div class="step-indicator">3</div>
              <span>Ready for processing</span>
            </div>
          </div>
        </div>
      
        <!-- OCR Status -->
        <div id="ocrStatus" style="display:none;" role="status" aria-live="polite" aria-atomic="true"></div>
      </div>
      

      <!-- AI Formatter Section Card -->
      <div class="section-card">
        <div class="section-header">
          <span class="material-icons" aria-hidden="true">auto_awesome</span>
          <h3>AI Formatter</h3>
        </div>

        <!-- Prompt Selection -->
        <div>
          <label class="section-label" for="promptSelect">Select Formatting Task</label>
          <select id="promptSelect" aria-label="Select formatting prompt">
            <option value="">‚Äî Choose a task ‚Äî</option>
            <option value="reflow">Reflow OCR text</option>
            <option value="list-to-csv">Normalize lists to CSV</option>
            <option value="fix-table">Fix table rows</option>
            <option value="clean-email">Clean email text</option>
            <option value="markdown">Convert to Markdown</option>
            <option value="html">Convert to HTML</option>
            <option value="latex">Convert to LaTeX</option>
            <option value="custom">+ Add new prompt</option>
          </select>
        </div>

        <!-- Quick prompt chips -->
        <div class="prompt-chips" role="group" aria-label="Quick formatting options">
          <button class="prompt-chip" data-prompt="reflow" aria-pressed="false">
            <span aria-hidden="true">üìÑ</span> Reflow text
          </button>
          <button class="prompt-chip" data-prompt="list-to-csv" aria-pressed="false">
            <span aria-hidden="true">üìã</span> List to CSV
          </button>
          <button class="prompt-chip" data-prompt="fix-table" aria-pressed="false">
            <span aria-hidden="true">üìä</span> Fix tables
          </button>
          <button class="prompt-chip" data-prompt="clean-email" aria-pressed="false">
            <span aria-hidden="true">‚úâÔ∏è</span> Clean email
          </button>
        </div>

        <!-- Custom Prompt Editor -->
        <div style="margin-top:var(--space-lg)">
          <label class="section-label" for="customPrompt">Custom Instructions</label>
          <textarea id="customPrompt" placeholder="Describe what you want the AI to do with your text..."
            aria-label="Custom prompt input"></textarea>
        </div>

        <!-- Prompt Actions -->
        <div style="display:flex;gap:var(--space-sm)">
          <button class="btn btn-secondary btn-sm" id="savePromptBtn">
            <span class="material-icons" aria-hidden="true">save</span>
            Save Prompt
          </button>
          <button class="btn btn-secondary btn-sm" id="testPromptBtn">
            <span class="material-icons" aria-hidden="true">science</span>
            Test
          </button>
          <button class="btn btn-secondary btn-sm" id="suggestPromptBtn">
            <span class="material-icons" aria-hidden="true">lightbulb</span>
            Suggest
          </button>
        </div>

        <!-- Saved Prompts -->
        <div id="savedPromptsSection" style="display:none;margin-top:var(--space-lg)">
          <label class="section-label">Saved Prompts</label>
          <div id="savedPromptsList" class="prompt-chips" role="list" aria-label="Saved prompts"></div>
        </div>
      </div>

      <!-- Process Controls Section Card -->
      <div class="section-card">
        <div class="progress-container-wide">
          <div class="progress-info">
            <span class="progress-label">Processing Status</span>
            <span id="statusText" class="status-pill status-ready" aria-live="polite">Ready</span>
          </div>
          <div class="progress-wide">
            <div class="progress-fill-wide" id="progressBar" role="progressbar" aria-valuenow="0" aria-valuemin="0"
              aria-valuemax="100"></div>
          </div>
        </div>

        <button class="btn btn-primary btn-process" id="processBtn" aria-label="Process document with AI">
          <span class="material-icons" aria-hidden="true">auto_awesome</span>
          Process with AI
        </button>

        <!-- Batch Processing -->
        <div class="batch-actions" style="display: none;" id="batchActions">
          <button class="btn btn-secondary btn-sm" id="batchProcessBtn">
            <span class="material-icons" aria-hidden="true">playlist_play</span>
            Process All
          </button>
          <button class="btn btn-text btn-sm" id="batchCancelBtn">
            <span class="material-icons" aria-hidden="true">cancel</span>
            Cancel
          </button>
        </div>
      </div>

      <!-- Document Library Section Card -->
      <div class="section-card">
        <div class="section-header">
          <span class="material-icons" aria-hidden="true">folder</span>
          <h3>Uploaded Documents</h3>
          <div style="margin-left: auto; display: flex; gap: var(--space-sm);">
            <button class="btn-text btn-sm" id="clearLibraryBtn" title="Clear all documents">
              <span class="material-icons" aria-hidden="true">delete_sweep</span>
            </button>
            <button class="btn-text btn-sm" id="batchSelectBtn" title="Batch processing">
              <span class="material-icons" aria-hidden="true">checklist</span>
            </button>
          </div>
        </div>
        <div class="document-grid" id="documentGrid" role="list" aria-label="Uploaded documents">
          <div class="empty-state">
            <span class="material-icons" aria-hidden="true">folder_open</span>
            No documents uploaded yet
          </div>
        </div>
      </div>
    </section>

    <!-- Right Panel: Output -->
    <section class="panel" aria-labelledby="output-panel-title">
      <div class="section-card section-card-full">
        <div class="section-header">
          <span class="material-icons" aria-hidden="true">article</span>
          <h3 id="output-panel-title">Formatted Output</h3>
          <div style="margin-left: auto; display: flex; gap: var(--space-sm);">
            <button class="btn-text btn-sm" id="outputFormatBtn" title="Change output format">
              <span class="material-icons" aria-hidden="true">code</span>
            </button>
          </div>
        </div>

        <textarea id="outputText" placeholder="AI-formatted results will appear here..."
          aria-label="Output text area"></textarea>

        <!-- Output Format Preview -->
        <div class="output-preview" id="outputPreview" style="display: none;">
          <div class="preview-tabs">
            <button class="preview-tab active" data-format="markdown">Markdown</button>
            <button class="preview-tab" data-format="html">HTML</button>
            <button class="preview-tab" data-format="latex">LaTeX</button>
          </div>
          <div class="preview-content">
            <pre id="previewContent"></pre>
          </div>
        </div>

        <!-- Output Actions -->
        <div class="output-actions">
          <button class="btn btn-primary" id="copyBtn">
            <span class="material-icons" aria-hidden="true">content_copy</span>
            Copy Output
          </button>
          <button class="btn btn-secondary" id="clearOutputBtn">
            <span class="material-icons" aria-hidden="true">clear</span>
            Clear
          </button>
          <button class="btn btn-secondary" id="reprocessBtn">
            <span class="material-icons" aria-hidden="true">refresh</span>
            Reprocess
          </button>
          <button class="btn btn-secondary" id="previewOutputBtn">
            <span class="material-icons" aria-hidden="true">visibility</span>
            Preview
          </button>
        </div>
      </div>
    </section>
  </main>

  <!-- Help Modal -->
  <div id="helpModal" class="modal" role="dialog" aria-labelledby="helpModalTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="helpModalTitle">ü§ñ AI Formatter Setup Guide</h3>
        <button class="modal-close" id="helpCloseBtn" aria-label="Close help modal">&times;</button>
      </div>

      <div style="font-size:14px;line-height:1.7;color:var(--text-secondary)">
        <!-- Step 1 -->
        <div class="help-step">
          <div class="help-step-header">
            <span class="step-number">1</span>
            <h4>What is AI Formatter?</h4>
          </div>
          <p>
            AI Formatter uses artificial intelligence to automatically clean and format your text. It can:
          </p>
          <ul>
            <li><strong>Fix messy OCR text</strong> from scanned documents</li>
            <li><strong>Remove extra spaces</strong> and broken line breaks</li>
            <li><strong>Reformat lists and tables</strong> automatically</li>
            <li><strong>Follow custom instructions</strong> through prompts</li>
            <li><strong>Convert between formats</strong> like Markdown, HTML, and LaTeX</li>
            <li><strong>Batch process</strong> multiple documents at once</li>
          </ul>
          <div class="info-box info-box-success">
            <span aria-hidden="true">üí°</span> No AI experience needed! Just follow these steps.
          </div>
        </div>

        <!-- Step 2 -->
        <div class="help-step">
          <div class="help-step-header">
            <span class="step-number">2</span>
            <h4>Get Your Free API Key</h4>
          </div>
          <div>
            <p>
              An <strong>API key</strong> is like a password that lets this tool talk to AI services.
            </p>

            <div class="api-option">
              <div class="api-option-header">ü§ó Recommended: DeepSeek (Free via Hugging Face)</div>
              <ol>
                <li>Visit <a href="https://huggingface.co/settings/tokens" target="_blank"
                    rel="noopener">huggingface.co/settings/tokens</a></li>
                <li>Sign up or log in to your account</li>
                <li>Click <strong>"New token"</strong></li>
                <li>Name it "AIFormatter"</li>
                <li>Select <strong>"Read"</strong> token type</li>
                <li>Click <strong>"Generate token"</strong></li>
                <li>Copy the token (starts with <code>hf_...</code>)</li>
              </ol>
            </div>

            <details>
              <summary class="alternative-option">üìå Alternative: Groq (Also Free)</summary>
              <div class="alternative-content">
                1. Visit <a href="https://console.groq.com" target="_blank" rel="noopener">console.groq.com</a><br>
                2. Sign up with your email<br>
                3. Go to <strong>"API Keys"</strong> in sidebar<br>
                4. Click <strong>"Create API Key"</strong><br>
                5. Name it and generate<br>
                6. Copy the key (starts with <code>gsk_...</code>)
              </div>
            </details>
          </div>
        </div>

        <!-- Step 3 -->
        <div class="help-step">
          <div class="help-step-header">
            <span class="step-number">3</span>
            <h4>Connect Your API Key</h4>
          </div>
          <ol>
            <li>Click <strong>"Settings"</strong> in the header</li>
            <li>Choose <strong>"DeepSeek (Hugging Face)"</strong> from Provider dropdown</li>
            <li>Paste your Hugging Face token in the field</li>
            <li>Click <strong>"Test Key"</strong> to verify it works</li>
            <li>Click <strong>"Save Settings"</strong></li>
          </ol>
          <div class="info-box info-box-success">
            <span aria-hidden="true">üéâ</span> Done! Your AI Formatter is ready.
          </div>
        </div>

        <!-- Step 4 -->
        <div class="help-step">
          <div class="help-step-header">
            <span class="step-number">4</span>
            <h4>How to Use</h4>
          </div>
          <p><strong>Quick Start:</strong></p>
          <ol>
            <li><strong>Add text:</strong> Upload a file OR paste text directly</li>
            <li><strong>Choose task:</strong> Select a formatting prompt from the AI Formatter section</li>
            <li><strong>Process:</strong> Click "Process with AI" button</li>
            <li><strong>Copy results:</strong> Click "Copy Output" when done</li>
          </ol>
          <div class="info-box info-box-info">
            <span aria-hidden="true">üí°</span> Pro Tip: Use the quick chips like "üìÑ Reflow text" for common tasks!
          </div>
        </div>

        <!-- Privacy -->
        <div class="info-box info-box-warning">
          <strong style="display:block;margin-bottom:var(--space-sm)"><span aria-hidden="true">üîí</span> Privacy
            Notice</strong>
          <div style="font-size:13px;line-height:1.6">
            Your text is sent to AI providers for processing. Don't use for highly sensitive data.
            Your API key stays on your device and is never sent to our servers.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- AI Settings Modal -->
  <div id="settingsModal" class="modal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="settingsModalTitle"><span aria-hidden="true">‚öôÔ∏è</span> AI Settings</h3>
        <button class="modal-close" id="settingsCloseBtn" aria-label="Close settings modal">&times;</button>
      </div>

      <div style="font-size:14px;line-height:1.7;color:var(--text-secondary)">
        <!-- Provider Selection -->
        <div>
          <label class="section-label" for="providerSelect">AI Provider</label>
          <select id="providerSelect" aria-label="Select AI provider">
            <option value="">‚Äî Select Provider ‚Äî</option>
            <option value="local">Local only (no API)</option>
            <option value="groq">Groq (free trial)</option>
            <option value="deepseek">DeepSeek (Hugging Face)</option>
            <option value="huggingface">Hugging Face (other models)</option>
            <option value="openai">OpenAI</option>
            <option value="custom">Custom endpoint</option>
          </select>
        </div>

        <!-- Model Override -->
        <div style="margin-top:var(--space-md)">
          <label class="section-label" for="modelInput">Model (optional)</label>
          <input id="modelInput" type="text" placeholder="e.g., deepseek-ai/DeepSeek-V3.2-Exp (leave blank for default)"
            aria-label="Model name input">
          <div class="info-box info-box-info" style="margin-top:var(--space-sm)">
            <span aria-hidden="true">üí°</span> Leave blank to use the provider's default model. Advanced users can
            specify custom models here.
          </div>
        </div>

        <!-- API Key -->
        <div id="apiKeySection" style="display:none;margin-top:var(--space-lg)">
          <label class="section-label" for="apiKeyInput">API Key</label>
          <div style="display:flex;gap:var(--space-sm)">
            <input id="apiKeyInput" type="password" placeholder="Enter your API key" aria-label="API key input"
              style="flex:1">
            <button class="btn btn-text" id="toggleKeyBtn" aria-label="Toggle API key visibility">
              <span class="material-icons" aria-hidden="true">visibility</span>
            </button>
          </div>

          <div style="margin-top:var(--space-md);display:flex;gap:var(--space-md);flex-wrap:wrap">
            <button class="btn btn-secondary" id="testKeyBtn" style="flex:1">
              <span class="material-icons" aria-hidden="true">check_circle</span>
              Test Key
            </button>
            <label style="display:flex;align-items:center;gap:var(--space-sm);cursor:pointer;flex:1">
              <input type="checkbox" id="saveKeyCheck" aria-label="Save API key locally">
              <span style="font-size:13px">Save key locally</span>
            </label>
          </div>

          <div class="info-box info-box-warning" style="margin-top:var(--space-md)">
            <span aria-hidden="true">‚ö†Ô∏è</span> Keys are stored in your browser only. Never share your API key. Don't
            save on shared computers.
          </div>
        </div>

        <!-- Custom Endpoint -->
        <div id="customEndpointSection" style="display:none;margin-top:var(--space-lg)">
          <label class="section-label" for="customUrl">Custom Endpoint URL</label>
          <input id="customUrl" type="url" placeholder="https://api.example.com/v1/chat/completions"
            aria-label="Custom endpoint URL">

          <div style="margin-top:var(--space-md)">
            <label class="section-label" for="customHeader">Header Key</label>
            <input id="customHeader" type="text" placeholder="Authorization" value="Authorization"
              aria-label="Custom header key">
          </div>
        </div>

        <!-- Help Links -->
        <div class="info-box info-box-info" style="margin-top:var(--space-lg)">
          <strong style="display:block;margin-bottom:var(--space-sm)"><span aria-hidden="true">üìå</span> Need an API
            key?</strong>
          <div style="font-size:13px;line-height:1.6">
            <div style="margin-bottom:var(--space-sm)">
              <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener"
                style="color:var(--brand-primary);font-weight:500;text-decoration:none">Hugging Face Tokens</a> ‚Äî Free,
              for DeepSeek models
            </div>
            <div style="margin-bottom:var(--space-sm)">
              <a href="https://console.groq.com" target="_blank" rel="noopener"
                style="color:var(--brand-primary);font-weight:500;text-decoration:none">Groq Console</a> ‚Äî Free trial,
              fast inference
            </div>
            <div>
              <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener"
                style="color:var(--brand-primary);font-weight:500;text-decoration:none">OpenAI Platform</a> ‚Äî Paid, high
              quality
            </div>
          </div>
        </div>

        <!-- Action Buttons -->
        <div style="display:flex;gap:var(--space-sm);margin-top:var(--space-lg)">
          <button class="btn btn-secondary" id="clearSettingsBtn" style="flex:1">Clear Settings</button>
          <button class="btn btn-primary" id="saveSettingsBtn" style="flex:1">Save Settings</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div id="shortcutsModal" class="modal" role="dialog" aria-labelledby="shortcutsModalTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="shortcutsModalTitle"><span aria-hidden="true">‚å®Ô∏è</span> Keyboard Shortcuts</h3>
        <button class="modal-close" id="shortcutsCloseBtn" aria-label="Close shortcuts modal">&times;</button>
      </div>

      <div class="shortcuts-grid">
        <div class="shortcut-item">
          <span>Process text</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">Enter</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Open Chat</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">/</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Copy output</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">Shift</kbd>
            <kbd class="shortcut-key">C</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Focus input</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">1</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Focus output</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">2</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Upload files</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">U</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Toggle theme</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Ctrl</kbd>
            <kbd class="shortcut-key">T</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Show shortcuts</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">?</kbd>
          </div>
        </div>
        <div class="shortcut-item">
          <span>Close modals</span>
          <div class="shortcut-keys">
            <kbd class="shortcut-key">Esc</kbd>
          </div>
        </div>
      </div>

      <div class="info-box info-box-info" style="margin-top: var(--space-lg);">
        <strong style="display:block;margin-bottom:var(--space-sm)">üí° Tip</strong>
        <div style="font-size:13px;line-height:1.6">
          These shortcuts work when you're not typing in a text field. On Mac, use <kbd>Cmd</kbd> instead of
          <kbd>Ctrl</kbd>.
        </div>
      </div>
    </div>
  </div>

  <!-- Template Library Modal -->
  <div id="templatesModal" class="modal" role="dialog" aria-labelledby="templatesModalTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="templatesModalTitle"><span aria-hidden="true">üìö</span> Prompt Template Library</h3>
        <button class="modal-close" id="templatesCloseBtn" aria-label="Close templates modal">&times;</button>
      </div>

      <div class="template-categories">
        <button class="template-category active" data-category="all">All Templates</button>
        <button class="template-category" data-category="formatting">Formatting</button>
        <button class="template-category" data-category="conversion">Conversion</button>
        <button class="template-category" data-category="cleaning">Cleaning</button>
        <button class="template-category" data-category="advanced">Advanced</button>
      </div>

      <div class="templates-grid" id="templatesGrid">
        <!-- Templates will be populated by JavaScript -->
      </div>
    </div>
  </div>
  <!-- Add this modal after the existing modals -->
  <div id="chatModal" class="modal" role="dialog" aria-labelledby="chatModalTitle" aria-modal="true">
    <div class="modal-content" style="max-width: 800px; height: 80vh; display: flex; flex-direction: column;">
      <div class="modal-header">
        <h3 id="chatModalTitle"><span aria-hidden="true">üí¨</span> Chat with AI</h3>
        <button class="modal-close" id="chatCloseBtn" aria-label="Close chat modal">&times;</button>
      </div>
  
      <div id="chatMessages"
        style="flex: 1; overflow-y: auto; padding: var(--space-md); background: var(--bg-secondary); border-radius: var(--radius-md); margin-bottom: var(--space-md); display: flex; flex-direction: column; gap: var(--space-md);">
        <!-- Messages will be populated here -->
        <div class="chat-message ai-message">
          <div class="message-content">
            <strong>AI Assistant:</strong> Hello! I'm here to help. You can ask me anything - questions about text
            formatting, help with prompts, or general assistance. What would you like to know?
          </div>
          <div class="message-time">Just now</div>
        </div>
      </div>
  
      <div style="display: flex; gap: var(--space-sm);">
        <textarea id="chatInput" placeholder="Type your message here..."
          style="flex: 1; min-height: 60px; resize: vertical; padding: var(--space-md); border: 1px solid var(--border-light); border-radius: var(--radius-md); background: var(--input-bg); color: var(--input-text);"
          aria-label="Chat input"></textarea>
        <button class="btn btn-primary" id="sendChatBtn" style="align-self: flex-end; min-height: 60px;">
          <span class="material-icons" aria-hidden="true">send</span>
        </button>
      </div>
  
      <div class="output-actions" style="margin-top: var(--space-md);">
        <button class="btn btn-secondary" id="clearChatBtn">
          <span class="material-icons" aria-hidden="true">clear_all</span>
          Clear Chat
        </button>
        <button class="btn btn-secondary" id="useChatOutputBtn">
          <span class="material-icons" aria-hidden="true">input</span>
          Use in Input
        </button>
        <button class="btn btn-secondary" id="exportChatBtn">
          <span class="material-icons" aria-hidden="true">download</span>
          Export Chat
        </button>
      </div>
    </div>
  </div>

  <script src="app.js"></script>
  <SCRipt>
    // ========================================
      // AI Formatter Pro - Complete Enhanced Version
      // ========================================

      const $id = id => document.getElementById(id);
      const $all = sel => document.querySelectorAll(sel);

      // ========================================
      // State Management
      // ========================================
      const State = {
        docs: new Map(),
        currentDoc: null,
        ocrWorker: null,
        savedPrompts: [],
        settings: {
          provider: '',
          apiKey: '',
          model: '',
          customUrl: '',
          customHeader: 'Authorization',
          saveKey: false,
          autoProcess: true
        },
        processing: false,
        batchProcessing: false,
        batchQueue: [],
        currentTheme: 'light',
        selectedFiles: new Map(),
        outputFormat: 'text',
        chatHistory: []
        
      };

      // ========================================
      // UI Utilities - Enhanced
      // ========================================
      const UI = {
        showToast(message, type = 'info', duration = 4000) {
          const icons = {
            success: 'check_circle',
            error: 'error',
            warning: 'warning',
            info: 'info'
          };

          const titles = {
            success: 'Success',
            error: 'Error',
            warning: 'Warning',
            info: 'Info'
          };

          // Remove existing toasts
          $all('.toast').forEach(toast => toast.remove());

          const toast = document.createElement('div');
          toast.className = `toast toast-${type}`;
          toast.setAttribute('role', 'alert');
          toast.setAttribute('aria-live', 'assertive');
          toast.innerHTML = `
            <span class="material-icons toast-icon">${icons[type]}</span>
            <div class="toast-content">
                <div class="toast-title">${titles[type]}</div>
                <div class="toast-message">${message}</div>
            </div>
            <button class="toast-close" aria-label="Dismiss notification">
                <span class="material-icons">close</span>
            </button>
        `;

          document.body.appendChild(toast);

          // Add click handler for close button
          const closeBtn = toast.querySelector('.toast-close');
          closeBtn.addEventListener('click', () => {
            toast.classList.add('toast-exit');
            setTimeout(() => toast.remove(), 300);
          });

          // Auto remove after duration
          if (duration > 0) {
            setTimeout(() => {
              if (toast.parentNode) {
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
              }
            }, duration);
          }

          return toast;
        },

        setProgress(percent) {
          const progressBar = $id('progressBar');
          progressBar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
          progressBar.setAttribute('aria-valuenow', Math.round(percent));
        },

        setStatus(text, type = 'ready') {
          const statusEl = $id('statusText');
          statusEl.textContent = text;
          statusEl.className = `status-pill status-${type}`;
          statusEl.setAttribute('aria-label', `Status: ${text}`);
        },

        showLoading(button, loading = true, text = 'Processing...') {
          if (loading) {
            button.disabled = true;
            button.setAttribute('aria-busy', 'true');
            button.dataset.originalText = button.innerHTML;
            button.innerHTML = `<div class="spinner" aria-hidden="true"></div> ${text}`;
          } else {
            button.disabled = false;
            button.removeAttribute('aria-busy');
            button.innerHTML = button.dataset.originalText || button.innerHTML;
          }
        },

        showConfetti() {
          const colors = ['#2563eb', '#3b82f6', '#60a5fa', '#93c5fd'];
          for (let i = 0; i < 50; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + 'vw';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confettiFall ${1 + Math.random() * 2}s linear forwards`;
            document.body.appendChild(confetti);

            setTimeout(() => {
              if (confetti.parentNode) {
                confetti.remove();
              }
            }, 3000);
          }
        },

        // Enhanced file drag and drop
        setupFileDrop(container, callback) {
          const handleDrag = (e) => {
            e.preventDefault();
            e.stopPropagation();
          };

          const handleDragOver = (e) => {
            handleDrag(e);
            container.classList.add('drag-over');
          };

          const handleDragLeave = (e) => {
            handleDrag(e);
            // Only remove class if leaving the container
            if (!container.contains(e.relatedTarget)) {
              container.classList.remove('drag-over');
            }
          };

          const handleDrop = (e) => {
            handleDrag(e);
            container.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0 && callback) {
              callback(files);
            }
          };

          container.addEventListener('dragenter', handleDragOver);
          container.addEventListener('dragover', handleDragOver);
          container.addEventListener('dragleave', handleDragLeave);
          container.addEventListener('drop', handleDrop);
        },

        // Theme management
        initTheme() {
          const savedTheme = localStorage.getItem('ai_formatter_theme') || 'light';
          State.currentTheme = savedTheme;
          this.applyTheme(savedTheme);
        },

        applyTheme(theme) {
          document.documentElement.setAttribute('data-theme', theme);
          State.currentTheme = theme;
          localStorage.setItem('ai_formatter_theme', theme);

          const themeIcon = $id('themeIcon');
          if (themeIcon) {
            themeIcon.textContent = theme === 'dark' ? 'light_mode' : 'dark_mode';
          }
        },

        toggleTheme() {
          const newTheme = State.currentTheme === 'light' ? 'dark' : 'light';
          this.applyTheme(newTheme);
        },

        // File preview management
        updateFilePreview() {
          const preview = $id('filePreview');
          if (State.selectedFiles.size === 0) {
            preview.style.display = 'none';
            return;
          }

          preview.style.display = 'flex';
          preview.innerHTML = '';

          State.selectedFiles.forEach((file, id) => {
            const fileExtension = file.name.toLowerCase().split('.').pop();
            const fileType = FileHandler.getFileType(file, fileExtension);

            const item = document.createElement('div');
            item.className = 'file-preview-item processing';
            item.innerHTML = `
                <div class="file-type-icon file-type-${fileType}">${FileHandler.getFileTypeIcon(fileType)}</div>
                <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" 
                      title="${file.name}">${file.name}</span>
                <div class="spinner" style="width: 12px; height: 12px;"></div>
                <button class="file-preview-remove" data-id="${id}" aria-label="Remove ${file.name}" style="margin-left: var(--space-sm);">
                    <span class="material-icons" aria-hidden="true">close</span>
                </button>
            `;
            preview.appendChild(item);
          });

          // Add event listeners for remove buttons
          $all('.file-preview-remove').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const fileId = e.currentTarget.dataset.id;
              State.selectedFiles.delete(fileId);
              this.updateFilePreview();
              UI.showToast('File removed from queue', 'info');
            });
          });
        }
      };

      // ========================================
      // Storage Utilities - Enhanced
      // ========================================
      const Storage = {
        save(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error('Storage save failed:', e);
            UI.showToast('Failed to save settings', 'error');
            return false;
          }
        },

        load(key, defaultValue = null) {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
          } catch (e) {
            console.error('Storage load failed:', e);
            return defaultValue;
          }
        },

        remove(key) {
          try {
            localStorage.removeItem(key);
            return true;
          } catch (e) {
            console.error('Storage remove failed:', e);
            return false;
          }
        }
      };

      // ========================================
      // API Providers
      // ========================================
      const Providers = {
        groq: {
          name: 'Groq',
          endpoint: 'https://api.groq.com/openai/v1/chat/completions',
          defaultModel: 'llama-3.3-70b-versatile',
          requiresKey: true
        },
        deepseek: {
          name: 'DeepSeek',
          endpoint: 'https://router.huggingface.co/v1',
          defaultModel: 'deepseek-ai/DeepSeek-V3.2-Exp:novita',
          requiresKey: true
        },
        huggingface: {
          name: 'Hugging Face',
          endpoint: 'https://api-inference.huggingface.co/models/',
          defaultModel: 'google/flan-t5-base',
          requiresKey: true
        },
        openai: {
          name: 'OpenAI',
          endpoint: 'https://api.openai.com/v1/chat/completions',
          defaultModel: 'gpt-3.5-turbo',
          requiresKey: true
        },
        local: {
          name: 'Local (No API)',
          endpoint: null,
          defaultModel: null,
          requiresKey: false
        }
      };

      // ========================================
      // AI Service - Enhanced with format conversion
      // ========================================
      const AIService = {
        async callProvider(prompt, userText, format = 'text') {
          const provider = State.settings.provider;
      
          // Auto-fallback to local processing for deployment safety
          if (!provider || provider === 'local') {
            return this.localProcessing(userText, format);
          }
      
          const config = Providers[provider];
          if (!config) {
            console.warn(`Invalid provider "${provider}", falling back to local processing`);
            return this.localProcessing(userText, format);
          }
      
          if (config.requiresKey && !State.settings.apiKey) {
            // Instead of throwing error, fall back to local processing
            console.warn(`No API key for ${config.name}, using local processing`);
            UI.showToast(`No API key configured. Using local processing instead.`, 'warning');
            return this.localProcessing(userText, format);
          }

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000);

          try {
            const response = await fetch(endpoint, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(body),
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
              let errorMsg = `API Error (${response.status})`;
              try {
                const errorData = await response.json();
                errorMsg = errorData.error?.message || errorData.message || JSON.stringify(errorData);
              } catch (e) {
                errorMsg += `: ${await response.text().catch(() => 'Unknown error')}`;
              }
              throw new Error(errorMsg);
            }

            const data = await response.json();
            UI.setProgress(90);

            return data.choices?.[0]?.message?.content || '';
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
              throw new Error('Request timeout - please try again');
            }
            throw error;
          }
        },

        async callDeepSeek(endpoint, model, prompt, userText, format) {
          const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${State.settings.apiKey}`
          };

          // Enhance prompt based on output format
          const enhancedPrompt = this.enhancePromptForFormat(prompt, format);

          const body = {
            model: model,
            messages: [
              {
                role: 'system',
                content: 'You are a text formatting assistant. Apply instructions exactly. Output only formatted text with no explanation.'
              },
              {
                role: 'user',
                content: `${enhancedPrompt}\n\nText to process:\n${userText}`
              }
            ],
            temperature: 0.3,
            max_tokens: 4096
          };

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000);

          try {
            const response = await fetch(endpoint + '/chat/completions', {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(body),
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
              let errorMsg = `DeepSeek API Error (${response.status})`;
              try {
                const errorData = await response.json();
                errorMsg = errorData.error?.message || errorData.message || JSON.stringify(errorData);
              } catch (e) {
                errorMsg += `: ${await response.text().catch(() => 'Unknown error')}`;
              }
              throw new Error(errorMsg);
            }

            const data = await response.json();
            UI.setProgress(90);

            return data.choices?.[0]?.message?.content || '';
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
              throw new Error('Request timeout - please try again');
            }
            throw error;
          }
        },

        async callHuggingFace(endpoint, model, prompt, userText, format) {
          const headers = {
            'Authorization': `Bearer ${State.settings.apiKey}`,
            'Content-Type': 'application/json'
          };

          // Enhance prompt based on output format
          const enhancedPrompt = this.enhancePromptForFormat(prompt, format);
          const fullPrompt = `${enhancedPrompt}\n\nText to format:\n${userText}\n\nFormatted text:`;

          const body = {
            inputs: fullPrompt,
            parameters: {
              max_new_tokens: 4096,
              temperature: 0.3,
              do_sample: true,
              return_full_text: false
            }
          };

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 45000);

          try {
            const response = await fetch(endpoint + model, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(body),
              signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
              let errorMsg = `Hugging Face API Error (${response.status})`;
              try {
                const errorData = await response.json();

                if (errorData.error && errorData.error.includes('loading')) {
                  const estimatedTime = errorData.estimated_time || 30;
                  errorMsg = `Model is loading. Please try again in about ${Math.ceil(estimatedTime)} seconds.`;
                } else {
                  errorMsg = errorData.error || errorData.message || JSON.stringify(errorData);
                }
              } catch (e) {
                errorMsg += `: ${await response.text().catch(() => 'Unknown error')}`;
              }
              throw new Error(errorMsg);
            }

            const data = await response.json();
            UI.setProgress(90);

            if (Array.isArray(data) && data[0] && data[0].generated_text) {
              return data[0].generated_text;
            } else if (data.generated_text) {
              return data.generated_text;
            } else {
              return JSON.stringify(data);
            }
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
              throw new Error('Request timeout - please try again');
            }
            throw error;
          }
        },

        enhancePromptForFormat(prompt, format) {
          const formatInstructions = {
            markdown: 'Format the output as clean Markdown with proper headings, lists, and emphasis.',
            html: 'Convert to clean HTML with proper semantic tags. Use paragraphs, lists, and tables where appropriate.',
            latex: 'Convert to LaTeX format with proper document structure, sections, and mathematical notation if needed.',
            text: 'Output clean, well-formatted plain text with proper paragraphs and spacing.'
          };

          const instruction = formatInstructions[format] || '';
          return instruction ? `${prompt}\n\n${instruction}` : prompt;
        },

        localProcessing(text, format) {
          UI.setStatus('Local processing...', 'processing');

          let processed = text
            .replace(/\r\n/g, '\n')
            .replace(/\n{3,}/g, '\n\n')
            .replace(/[ \t]+/g, ' ')
            .replace(/^\s+|\s+$/gm, '')
            .trim();

          // Basic format conversion
          if (format === 'markdown') {
            processed = this.convertToMarkdown(processed);
          } else if (format === 'html') {
            processed = this.convertToHTML(processed);
          }

          UI.setProgress(100);
          return processed;
        },

        convertToMarkdown(text) {
          // Simple markdown conversion
          return text
            .replace(/^(#+)\s*(.*)$/gm, '# $2') // Basic headings
            .replace(/\n{2,}/g, '\n\n') // Normalize line breaks
            .replace(/^\s*[-*]\s+/gm, '- ') // Lists
            .replace(/\b(\d+)\.\s+/g, '$1. ') // Numbered lists
            .trim();
        },

        convertToHTML(text) {
          // Simple HTML conversion
          return text
            .split('\n\n')
            .map(para => para.trim() ? `<p>${para}</p>` : '')
            .join('\n')
            .replace(/^\s*[-*]\s+(.*)$/gm, '<li>$1</li>') // Lists
            .replace(/(<li>.*<\/li>)/s, '<ul>\n$1\n</ul>'); // Wrap lists
        },

        async testConnection() {
          const testPrompt = 'Respond with exactly: TEST OK';
          const testText = 'test';

          try {
            const result = await this.callProvider(testPrompt, testText);

            if (result && result.includes('TEST OK')) {
              return true;
            }
            return false;
          } catch (error) {
            if (error.message.includes('loading')) {
              throw new Error('Model is loading, please try again in a moment');
            }
            throw error;
          }
        }
      };

      // ========================================
      // Enhanced OCR Service with Better Error Handling
      // ========================================
      const OCRService = {
        async init() {
          if (State.ocrWorker) return;

          try {
            UI.showToast('Initializing OCR engine...', 'info');
            State.ocrWorker = await Tesseract.createWorker({
              logger: m => {
                if (m.status === 'recognizing text') {
                  UI.setProgress(m.progress * 100);
                }
              }
            });
            await State.ocrWorker.loadLanguage('eng');
            await State.ocrWorker.initialize('eng');
            UI.showToast('OCR engine ready', 'success');
          } catch (error) {
            console.error('OCR init failed:', error);
            State.ocrWorker = null;
            throw new Error('Failed to initialize OCR engine. Please refresh the page and try again.');
          }
        },

        async processImage(file) {
          await this.init();

          if (!State.ocrWorker) {
            throw new Error('OCR worker not available');
          }

          UI.setStatus('Processing image...', 'processing');
          $id('ocrStatus').style.display = 'block';
          $id('ocrStatus').innerHTML = '<div style="color:var(--brand-primary)">Extracting text from image...</div>';

          try {
            const { data: { text } } = await State.ocrWorker.recognize(file);

            if (!text || text.trim().length === 0) {
              throw new Error('No text could be extracted from this image');
            }

            $id('ocrStatus').innerHTML = '<div style="color:var(--success)">‚úì Image processing complete!</div>';
            setTimeout(() => { $id('ocrStatus').style.display = 'none'; }, 2500);

            return text.trim();
          } catch (error) {
            $id('ocrStatus').innerHTML = '<div style="color:var(--error)">‚úó Image processing failed</div>';
            throw error;
          }
        },

        async processPDF(file) {
          UI.setStatus('Processing PDF...', 'processing');
          $id('ocrStatus').style.display = 'block';
          $id('ocrStatus').innerHTML = '<div style="color:var(--brand-primary)">Loading PDF...</div>';

          try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const totalPages = pdf.numPages;

            $id('ocrStatus').innerHTML = `<div style="color:var(--brand-primary)">Processing ${totalPages} page(s)...</div>`;

            const textPages = [];
            let hasTextContent = false;

            for (let i = 1; i <= totalPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');

              if (pageText.trim().length > 20) {
                textPages.push(pageText);
                hasTextContent = true;
              } else {
                // Fall back to OCR for this page
                UI.showToast(`Page ${i} has no selectable text, using OCR...`, 'info');
                const canvas = document.createElement('canvas');
                const viewport = page.getViewport({ scale: 2.0 });
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({ canvasContext: ctx, viewport }).promise;

                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const { data: { text } } = await State.ocrWorker.recognize(blob);
                if (text && text.trim().length > 0) {
                  textPages.push(text.trim());
                  hasTextContent = true;
                }
              }

              UI.setProgress((i / totalPages) * 100);
              $id('ocrStatus').innerHTML = `<div style="color:var(--brand-primary)">Processing page ${i}/${totalPages}...</div>`;
            }

            if (!hasTextContent) {
              throw new Error('No text content could be extracted from this PDF');
            }

            $id('ocrStatus').innerHTML = '<div style="color:var(--success)">‚úì PDF processing complete!</div>';
            setTimeout(() => { $id('ocrStatus').style.display = 'none'; }, 2500);

            return textPages.join('\n\n');
          } catch (error) {
            $id('ocrStatus').innerHTML = '<div style="color:var(--error)">‚úó PDF processing failed</div>';
            throw error;
          }
        },

        cleanup() {
          if (State.ocrWorker) {
            State.ocrWorker.terminate();
            State.ocrWorker = null;
          }
        }
      };

      // ========================================
      // Enhanced File Handler with Better Text Extraction
      // ========================================
      const FileHandler = {
        async handle(files) {
          if (!files || files.length === 0) return;

          UI.showToast(`Processing ${files.length} file(s)...`, 'info');

          // Show processing steps
          this.showProcessingSteps();

          for (const file of files) {
            const fileId = Math.random().toString(36).slice(2, 10);
            State.selectedFiles.set(fileId, file);

            // Update file preview immediately
            UI.updateFilePreview();

            try {
              // Process the file immediately
              await this.processSingleFile(fileId, file);
            } catch (error) {
              console.error('File processing error:', error);
              UI.showToast(`Error processing ${file.name}: ${error.message}`, 'error');
            }
          }

          // Complete processing steps
          this.completeProcessingSteps();
        },

        async processSingleFile(fileId, file) {
          const doc = new Doc(file);
          State.docs.set(doc.id, doc);
          this.renderDocCard(doc);

          try {
            // Update step 2: Extracting text
            this.updateProcessingStep('stepExtract', 'active', `Extracting text from ${file.name}...`);

            doc.status = 'processing';
            this.updateDocCard(doc);

            let text = '';
            const fileExtension = file.name.toLowerCase().split('.').pop();

            // Enhanced file type detection
            if (file.type === 'application/pdf' || fileExtension === 'pdf') {
              text = await OCRService.processPDF(file);
            } else if (file.type.startsWith('image/') ||
              ['jpg', 'jpeg', 'png', 'tiff', 'bmp', 'gif'].includes(fileExtension)) {
              text = await OCRService.processImage(file);
            } else if (file.type === 'text/plain' || fileExtension === 'txt') {
              text = await this.readTextFile(file);
            } else if (fileExtension === 'doc' || fileExtension === 'docx') {
              text = await this.handleWordDocument(file);
            } else {
              throw new Error(`Unsupported file type: ${file.type}`);
            }

            if (!text || text.trim().length === 0) {
              throw new Error('No text could be extracted from this file');
            }

            doc.extractedText = text;
            doc.status = 'ready';
            this.updateDocCard(doc);

            // Add text to input area
            this.appendTextToInput(text, doc.name);

            // Remove from selected files
            State.selectedFiles.delete(fileId);
            UI.updateFilePreview();

            if (!State.currentDoc) {
              State.currentDoc = doc;
              this.setActiveDoc(doc.id);
            }

            UI.showToast(`Successfully processed ${doc.name}`, 'success');

          } catch (error) {
            console.error('File processing error:', error);
            doc.status = 'error';
            this.updateDocCard(doc);
            State.selectedFiles.delete(fileId);
            UI.updateFilePreview();
            throw error;
          }
        },

        async readTextFile(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('Failed to read text file'));
            reader.readAsText(file);
          });
        },

        async handleWordDocument(file) {
          // For Word documents, we'll show a message since we can't process them directly
          // In a real implementation, you might use a library like mammoth.js
          throw new Error('Word document processing requires additional setup. Please convert to PDF or text first.');
        },

        appendTextToInput(text, fileName) {
          const textInput = $id('textInput');
          const separator = `\n\n--- ${fileName} ---\n`;

          if (textInput.value.includes(separator)) {
            // Update existing section
            const sections = textInput.value.split(separator);
            if (sections.length >= 2) {
              sections[1] = text;
              textInput.value = sections[0] + separator + sections.slice(1).join(separator);
            }
          } else {
            // Add new section
            const currentText = textInput.value;
            textInput.value = currentText ? `${currentText}${separator}${text}` : `${separator}${text}`;
          }

          // Ensure the new content is visible
          textInput.focus();
          textInput.scrollTop = textInput.scrollHeight;

          // Trigger content analysis
          ContentAnalyzer.updateAnalysisDisplay(textInput.value);
        },

        showProcessingSteps() {
          const stepsContainer = $id('processingSteps');
          stepsContainer.style.display = 'block';

          // Reset all steps
          $all('.processing-step').forEach(step => {
            step.classList.remove('active', 'completed');
          });

          // Activate first step
          $id('stepUpload').classList.add('active');
        },

        updateProcessingStep(stepId, state, text = '') {
          const step = $id(stepId);
          const allSteps = $all('.processing-step');

          // Update step state
          step.classList.remove('active', 'completed');
          if (state === 'active') {
            step.classList.add('active');
          } else if (state === 'completed') {
            step.classList.add('completed');
          }

          // Update text if provided
          if (text && step.querySelector('span')) {
            step.querySelector('span').textContent = text;
          }

          // Update step indicators
          if (state === 'completed') {
            const stepIndex = Array.from(allSteps).indexOf(step);
            const nextStep = allSteps[stepIndex + 1];
            if (nextStep && !nextStep.classList.contains('active') && !nextStep.classList.contains('completed')) {
              nextStep.classList.add('active');
            }
          }
        },

        completeProcessingSteps() {
          // Mark all steps as completed
          $all('.processing-step').forEach(step => {
            step.classList.remove('active');
            step.classList.add('completed');
          });

          // Hide after delay
          setTimeout(() => {
            $id('processingSteps').style.display = 'none';
          }, 2000);
        },

        getFileType(file, extension) {
          if (file.type === 'application/pdf' || extension === 'pdf') return 'pdf';
          if (file.type.startsWith('image/') || ['jpg', 'jpeg', 'png', 'tiff', 'bmp', 'gif'].includes(extension)) return 'image';
          if (file.type === 'text/plain' || extension === 'txt') return 'text';
          if (extension === 'doc' || extension === 'docx') return 'word';
          return 'unknown';
        },

        getFileTypeIcon(fileType) {
          const icons = {
            pdf: 'PDF',
            image: 'IMG',
            text: 'TXT',
            word: 'DOC',
            unknown: 'FILE'
          };
          return icons[fileType] || 'FILE';
        },

        // Enhanced document card rendering
        renderDocCard(doc) {
          const grid = $id('documentGrid');
          if (grid.children[0]?.classList.contains('empty-state')) {
            grid.innerHTML = '';
          }

          const card = document.createElement('div');
          card.className = 'document-card';
          card.dataset.id = doc.id;
          card.setAttribute('role', 'listitem');
          card.setAttribute('draggable', 'true');

          const fileType = this.getFileType(doc.file, doc.name.toLowerCase().split('.').pop());

          card.innerHTML = `
            <div class="doc-info">
                <div style="display: flex; align-items: center; gap: var(--space-sm); margin-bottom: 2px;">
                    <div class="file-type-icon file-type-${fileType}">${this.getFileTypeIcon(fileType)}</div>
                    <div class="doc-name">${this.escapeHtml(doc.name)}</div>
                </div>
                <div class="doc-meta">
                    ${(doc.size / 1024 / 1024).toFixed(2)} MB ‚Ä¢ 
                    ${new Date(doc.uploadedAt).toLocaleString()} ‚Ä¢
                    <span style="color: var(--text-muted);">${doc.extractedText ? doc.extractedText.length + ' chars' : 'Processing...'}</span>
                </div>
            </div>
            <div class="status-pill status-${doc.status}">${this.getStatusLabel(doc.status)}</div>
            <div class="document-card-actions">
                <button class="btn-text btn-sm" data-action="view" title="View extracted text">
                    <span class="material-icons" aria-hidden="true">visibility</span>
                </button>
                <button class="btn-text btn-sm" data-action="remove" title="Remove document">
                    <span class="material-icons" aria-hidden="true">delete</span>
                </button>
            </div>
        `;

          card.addEventListener('click', (e) => {
            if (!e.target.closest('[data-action]')) {
              this.setActiveDoc(doc.id);
              $id('textInput').value = doc.extractedText;
            }
          });

          // View extracted text button
          const viewBtn = card.querySelector('[data-action="view"]');
          viewBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.showExtractedText(doc);
          });

          // Remove button
          const removeBtn = card.querySelector('[data-action="remove"]');
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.removeDoc(doc.id);
          });

          // Drag and drop
          card.addEventListener('dragstart', (e) => {
            card.classList.add('dragging');
            e.dataTransfer.setData('text/plain', doc.id);
          });

          card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
          });

          // Keyboard support
          card.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              this.setActiveDoc(doc.id);
              $id('textInput').value = doc.extractedText;
            } else if (e.key === 'Delete') {
              e.preventDefault();
              this.removeDoc(doc.id);
            }
          });

          card.setAttribute('tabindex', '0');
          card.setAttribute('aria-label', `Document: ${doc.name}, ${this.getStatusLabel(doc.status)}`);

          grid.prepend(card);
        },

        showExtractedText(doc) {
          const text = doc.extractedText || 'No text extracted yet.';
          const modal = document.createElement('div');
          modal.className = 'modal active';
          modal.innerHTML = `
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h3>Extracted Text: ${doc.name}</h3>
                    <button class="modal-close" aria-label="Close modal">&times;</button>
                </div>
                <div style="max-height: 400px; overflow-y: auto; padding: var(--space-md); background: var(--bg-secondary); border-radius: var(--radius-md);">
                    <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${this.escapeHtml(text)}</pre>
                </div>
                <div style="margin-top: var(--space-lg); display: flex; gap: var(--space-sm); justify-content: flex-end;">
                    <button class="btn btn-secondary" id="copyExtractedText">Copy Text</button>
                    <button class="btn btn-primary" id="useExtractedText">Use This Text</button>
                </div>
            </div>
        `;

          document.body.appendChild(modal);

          // Close button
          modal.querySelector('.modal-close').addEventListener('click', () => {
            modal.remove();
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.remove();
            }
          });

          // Copy text button
          modal.querySelector('#copyExtractedText').addEventListener('click', () => {
            navigator.clipboard.writeText(text).then(() => {
              UI.showToast('Text copied to clipboard', 'success');
            });
          });

          // Use text button
          modal.querySelector('#useExtractedText').addEventListener('click', () => {
            $id('textInput').value = text;
            this.setActiveDoc(doc.id);
            modal.remove();
            UI.showToast('Text loaded into input area', 'success');
          });

          // Close on escape
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              modal.remove();
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        },

        setActiveDoc(docId) {
          State.currentDoc = State.docs.get(docId);
          $all('.document-card').forEach(c => {
            c.classList.remove('active');
            c.setAttribute('aria-selected', 'false');
          });

          const activeCard = document.querySelector(`.document-card[data-id="${docId}"]`);
          if (activeCard) {
            activeCard.classList.add('active');
            activeCard.setAttribute('aria-selected', 'true');
            activeCard.focus();
          }
        },

        removeDoc(docId) {
          if (confirm('Are you sure you want to remove this document?')) {
            State.docs.delete(docId);
            const card = document.querySelector(`.document-card[data-id="${docId}"]`);
            if (card) card.remove();

            if (State.currentDoc && State.currentDoc.id === docId) {
              State.currentDoc = null;
              $id('textInput').value = '';
            }

            // Show empty state if no documents left
            if (State.docs.size === 0) {
              const grid = $id('documentGrid');
              grid.innerHTML = `
                    <div class="empty-state">
                        <span class="material-icons" aria-hidden="true">folder_open</span>
                        No documents uploaded yet
                    </div>
                `;
            }

            UI.showToast('Document removed', 'info');
          }
        },

        clearLibrary() {
          if (State.docs.size === 0) return;

          if (confirm('Are you sure you want to clear all documents?')) {
            State.docs.clear();
            State.currentDoc = null;
            $id('documentGrid').innerHTML = `
                <div class="empty-state">
                    <span class="material-icons" aria-hidden="true">folder_open</span>
                    No documents uploaded yet
                </div>
            `;
            $id('textInput').value = '';
            UI.showToast('All documents cleared', 'info');
          }
        },

        updateDocCard(doc) {
          const card = document.querySelector(`.document-card[data-id="${doc.id}"]`);
          if (!card) return;

          const statusEl = card.querySelector('.status-pill');
          statusEl.className = `status-pill status-${doc.status}`;
          statusEl.textContent = this.getStatusLabel(doc.status);

          card.setAttribute('aria-label', `Document: ${doc.name}, ${this.getStatusLabel(doc.status)}`);
        },

        getStatusLabel(status) {
          const labels = {
            uploaded: 'Uploaded',
            processing: 'Processing',
            ready: 'Ready',
            error: 'Error'
          };
          return labels[status] || status;
        },

        escapeHtml(unsafe) {
          return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        },

        // Batch processing
        setupBatchProcessing() {
          const batchActions = $id('batchActions');
          const batchSelectBtn = $id('batchSelectBtn');

          let batchMode = false;

          batchSelectBtn.addEventListener('click', () => {
            batchMode = !batchMode;

            if (batchMode) {
              batchActions.style.display = 'flex';
              batchSelectBtn.innerHTML = '<span class="material-icons" aria-hidden="true">checklist_rtl</span>';
              batchSelectBtn.setAttribute('title', 'Exit batch mode');

              // Add batch selection UI
              $all('.document-card').forEach(card => {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'batch-checkbox';
                checkbox.style.marginRight = 'var(--space-sm)';
                card.querySelector('.doc-info').prepend(checkbox);
              });
            } else {
              batchActions.style.display = 'none';
              batchSelectBtn.innerHTML = '<span class="material-icons" aria-hidden="true">checklist</span>';
              batchSelectBtn.setAttribute('title', 'Batch processing');

              // Remove batch selection UI
              $all('.batch-checkbox').forEach(checkbox => checkbox.remove());
            }
          });

          $id('batchProcessBtn').addEventListener('click', () => {
            this.processBatch();
          });

          $id('batchCancelBtn').addEventListener('click', () => {
            batchSelectBtn.click(); // Exit batch mode
          });
        },

        async processBatch() {
          const selectedDocs = Array.from($all('.batch-checkbox:checked'))
            .map(checkbox => {
              const card = checkbox.closest('.document-card');
              return card ? card.dataset.id : null;
            })
            .filter(id => id)
            .map(id => State.docs.get(id))
            .filter(doc => doc && doc.status === 'ready');

          if (selectedDocs.length === 0) {
            UI.showToast('No ready documents selected for batch processing', 'warning');
            return;
          }

          State.batchProcessing = true;
          State.batchQueue = selectedDocs;

          UI.showToast(`Starting batch processing of ${selectedDocs.length} documents`, 'info');

          for (const doc of selectedDocs) {
            await this.processSingleDocInBatch(doc);
          }

          State.batchProcessing = false;
          UI.showToast('Batch processing completed', 'success');
        },

        async processSingleDocInBatch(doc) {
          const prompt = $id('customPrompt').value.trim();
          if (!prompt) {
            UI.showToast('No prompt specified for batch processing', 'error');
            return;
          }

          try {
            doc.status = 'processing';
            this.updateDocCard(doc);

            const result = await AIService.callProvider(prompt, doc.extractedText, State.outputFormat);

            // Store result with document
            doc.processedResult = result;
            doc.status = 'ready';
            this.updateDocCard(doc);

            UI.showToast(`Processed: ${doc.name}`, 'success');
          } catch (error) {
            doc.status = 'error';
            this.updateDocCard(doc);
            UI.showToast(`Failed to process ${doc.name}: ${error.message}`, 'error');
          }
        }
      };

      // ========================================
      // Document Class
      // ========================================
      class Doc {
        constructor(file) {
          this.id = Math.random().toString(36).slice(2, 10);
          this.file = file;
          this.name = file.name;
          this.type = file.type;
          this.size = file.size;
          this.uploadedAt = Date.now();
          this.status = 'uploaded';
          this.extractedText = '';
          this.processedResult = '';
        }
      }

      // ========================================
      // Content Analysis
      // ========================================
      const ContentAnalyzer = {
        analyze(text) {
          if (!text || text.length < 10) return null;

          const analysis = {
            type: 'unknown',
            wordCount: text.split(/\s+/).length,
            lineCount: text.split('\n').length,
            hasLists: false,
            hasTables: false,
            hasEmail: false,
            suggestions: []
          };

          // Detect content type
          if (text.match(/\d+\.\s|[-*‚Ä¢]\s/)) {
            analysis.type = 'list';
            analysis.hasLists = true;
            analysis.suggestions.push('list-to-csv');
          }

          if (text.match(/\t|\s{2,}.+\s{2,}/) || text.split('\n').some(line => line.split(/\s{2,}/).length >= 3)) {
            analysis.type = 'table';
            analysis.hasTables = true;
            analysis.suggestions.push('fix-table');
          }

          if (text.includes('@') && (text.includes('Subject:') || text.includes('From:') || text.includes('To:'))) {
            analysis.type = 'email';
            analysis.hasEmail = true;
            analysis.suggestions.push('clean-email');
          }

          if (analysis.type === 'unknown' && text.length > 100) {
            analysis.type = 'text';
            analysis.suggestions.push('reflow');
          }

          return analysis;
        },

        updateAnalysisDisplay(text) {
          const analysisContainer = $id('contentAnalysis');
          const resultsContainer = $id('analysisResults');

          if (!text || text.length < 50) {
            analysisContainer.style.display = 'none';
            return;
          }

          const analysis = this.analyze(text);
          if (!analysis) {
            analysisContainer.style.display = 'none';
            return;
          }

          analysisContainer.style.display = 'block';

          let html = `
            <div style="display: flex; gap: var(--space-lg); flex-wrap: wrap;">
                <div><strong>Type:</strong> ${analysis.type}</div>
                <div><strong>Words:</strong> ${analysis.wordCount}</div>
                <div><strong>Lines:</strong> ${analysis.lineCount}</div>
            </div>
        `;

          if (analysis.suggestions.length > 0) {
            html += `<div style="margin-top: var(--space-sm);"><strong>Suggestions:</strong> `;
            html += analysis.suggestions.map(suggestion =>
              `<button class="btn-text btn-sm" data-suggestion="${suggestion}" style="font-size: 12px; padding: 2px 6px;">${suggestion}</button>`
            ).join(' ');
            html += `</div>`;
          }

          resultsContainer.innerHTML = html;

          // Add event listeners to suggestion buttons
          $all('[data-suggestion]').forEach(btn => {
            btn.addEventListener('click', () => {
              const suggestion = btn.dataset.suggestion;
              Prompts.apply(suggestion);
              UI.showToast(`Applied suggestion: ${suggestion}`, 'info');
            });
          });
        }
      };

      // ========================================
      // Template Library
      // ========================================
      const TemplateLibrary = {
        templates: [
          {
            id: 'academic-paper',
            name: 'Academic Paper Format',
            category: 'formatting',
            description: 'Format text as an academic paper with proper sections and citations',
            prompt: 'Format this text as an academic paper. Include abstract, introduction, methods, results, and discussion sections. Use proper academic language and citation format.',
            preview: 'Abstract: ...\n1. Introduction\n2. Methods\n3. Results\n4. Discussion\nReferences'
          },
          {
            id: 'business-report',
            name: 'Business Report',
            category: 'formatting',
            description: 'Convert text into a professional business report format',
            prompt: 'Format this text as a business report with executive summary, key findings, recommendations, and conclusion. Use professional business language.',
            preview: 'Executive Summary\nKey Findings\nRecommendations\nConclusion'
          },
          {
            id: 'markdown-converter',
            name: 'Markdown Converter',
            category: 'conversion',
            description: 'Convert plain text to clean Markdown format',
            prompt: 'Convert this text to clean Markdown format with proper headings, lists, bold/italic emphasis, and code blocks where appropriate.',
            preview: '# Heading\n\n- List item\n- Another item\n\n**Bold text** and *italic text*'
          },
          {
            id: 'html-converter',
            name: 'HTML Converter',
            category: 'conversion',
            description: 'Convert text to semantic HTML',
            prompt: 'Convert this text to clean HTML with proper semantic tags. Use paragraphs, headings, lists, and tables where appropriate.',
            preview: '<h1>Heading</h1>\n<p>Paragraph text</p>\n<ul>\n  <li>List item</li>\n</ul>'
          },
          {
            id: 'email-cleaner',
            name: 'Email Cleaner',
            category: 'cleaning',
            description: 'Remove email headers and signatures',
            prompt: 'Remove all email headers, signatures, and quoted text. Keep only the main message content in clean paragraphs.',
            preview: 'Main email content without headers or signatures...'
          },
          {
            id: 'ocr-cleanup',
            name: 'OCR Cleanup',
            category: 'cleaning',
            description: 'Fix common OCR errors and formatting issues',
            prompt: 'Fix OCR errors including broken words, incorrect line breaks, and spacing issues. Preserve the original meaning and structure.',
            preview: 'Clean text without OCR artifacts...'
          },
          {
            id: 'meeting-notes',
            name: 'Meeting Notes Organizer',
            category: 'advanced',
            description: 'Organize messy meeting notes into structured format',
            prompt: 'Organize these meeting notes into a structured format with clear sections for attendees, agenda, decisions, and action items.',
            preview: 'Attendees: ...\nAgenda: ...\nDecisions: ...\nAction Items: ...'
          },
          {
            id: 'code-documentation',
            name: 'Code Documentation',
            category: 'advanced',
            description: 'Generate documentation from code comments',
            prompt: 'Extract and format documentation from code comments. Create clear function descriptions, parameters, and return values.',
            preview: '## Function Name\nDescription...\n\n**Parameters:**\n- param1: description\n\n**Returns:** description'
          }
        ],

        init() {
          this.renderCategories();
          this.renderTemplates('all');
        },

        renderCategories() {
          const categories = ['all', 'formatting', 'conversion', 'cleaning', 'advanced'];
          const container = $id('templatesModal').querySelector('.template-categories');

          categories.forEach(category => {
            const btn = container.querySelector(`[data-category="${category}"]`);
            if (btn) {
              btn.addEventListener('click', () => {
                // Update active category
                container.querySelectorAll('.template-category').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Render templates for this category
                this.renderTemplates(category);
              });
            }
          });
        },

        renderTemplates(category) {
          const grid = $id('templatesGrid');
          const filteredTemplates = category === 'all'
            ? this.templates
            : this.templates.filter(t => t.category === category);

          grid.innerHTML = filteredTemplates.map(template => `
            <div class="template-card" data-id="${template.id}">
                <h4>${template.name}</h4>
                <p>${template.description}</p>
                <div class="template-preview">${template.preview}</div>
            </div>
        `).join('');

          // Add click handlers
          $all('.template-card').forEach(card => {
            card.addEventListener('click', () => {
              const templateId = card.dataset.id;
              this.applyTemplate(templateId);
            });
          });
        },

        applyTemplate(templateId) {
          const template = this.templates.find(t => t.id === templateId);
          if (!template) return;

          $id('customPrompt').value = template.prompt;
          $id('promptSelect').value = 'custom';
          $id('templatesModal').classList.remove('active');

          UI.showToast(`Applied template: ${template.name}`, 'success');
        }
      };

      // ========================================
      // Output Format Manager
      // ========================================
      const OutputManager = {
        init() {
          this.setupFormatPreview();
          this.setupOutputActions();
        },

        setupFormatPreview() {
          const previewBtn = $id('previewOutputBtn');
          const formatBtn = $id('outputFormatBtn');
          const preview = $id('outputPreview');
          const tabs = $all('.preview-tab');

          previewBtn.addEventListener('click', () => {
            const output = $id('outputText').value;
            if (!output.trim()) {
              UI.showToast('No output to preview', 'warning');
              return;
            }

            preview.style.display = 'block';
            this.updatePreview(output, 'markdown');
          });

          formatBtn.addEventListener('click', () => {
            const formats = ['text', 'markdown', 'html', 'latex'];
            const currentIndex = formats.indexOf(State.outputFormat);
            const nextIndex = (currentIndex + 1) % formats.length;
            State.outputFormat = formats[nextIndex];

            formatBtn.innerHTML = `<span class="material-icons" aria-hidden="true">${this.getFormatIcon(State.outputFormat)}</span>`;
            formatBtn.setAttribute('title', `Output format: ${State.outputFormat.toUpperCase()}`);

            UI.showToast(`Output format set to: ${State.outputFormat.toUpperCase()}`, 'info');
          });

          // Tab switching
          tabs.forEach(tab => {
            tab.addEventListener('click', () => {
              tabs.forEach(t => t.classList.remove('active'));
              tab.classList.add('active');

              const format = tab.dataset.format;
              const output = $id('outputText').value;
              this.updatePreview(output, format);
            });
          });
        },

        getFormatIcon(format) {
          const icons = {
            text: 'text_fields',
            markdown: 'code',
            html: 'html',
            latex: 'functions'
          };
          return icons[format] || 'text_fields';
        },

        updatePreview(content, format) {
          const previewContent = $id('previewContent');

          if (!content) {
            previewContent.textContent = 'No content to preview';
            return;
          }

          let formattedContent = content;

          // Basic format conversion for preview
          switch (format) {
            case 'markdown':
              formattedContent = this.convertToMarkdown(content);
              break;
            case 'html':
              formattedContent = this.convertToHTML(content);
              break;
            case 'latex':
              formattedContent = this.convertToLaTeX(content);
              break;
          }

          previewContent.textContent = formattedContent;
        },

        convertToMarkdown(text) {
          // Simple markdown conversion for preview
          return text
            .replace(/^(#+)\s*(.*)$/gm, '# $2')
            .replace(/\n{2,}/g, '\n\n')
            .replace(/^\s*[-*]\s+/gm, '- ')
            .replace(/\b(\d+)\.\s+/g, '$1. ');
        },

        convertToHTML(text) {
          // Simple HTML conversion for preview
          return text
            .split('\n\n')
            .map(para => para.trim() ? `<p>${para}</p>` : '')
            .join('\n')
            .replace(/^\s*[-*]\s+(.*)$/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>)/s, '<ul>\n$1\n</ul>');
        },

        convertToLaTeX(text) {
          // Basic LaTeX conversion for preview
          return text
            .split('\n\n')
            .map(para => para.trim() ? para + '\n' : '')
            .join('\n')
            .replace(/^\s*[-*]\s+(.*)$/gm, '\\item $1')
            .replace(/(\\item.*)/s, '\\begin{itemize}\n$1\n\\end{itemize}');
        },

        setupOutputActions() {
          // Enhanced copy functionality
          $id('copyBtn').addEventListener('click', () => {
            const output = $id('outputText').value;
            if (!output.trim()) {
              UI.showToast('No output to copy', 'warning');
              return;
            }

            navigator.clipboard.writeText(output).then(() => {
              UI.showToast('Output copied to clipboard', 'success');
            }).catch(() => {
              // Fallback for older browsers
              $id('outputText').select();
              document.execCommand('copy');
              UI.showToast('Output copied to clipboard', 'success');
            });
          });

          // Export functionality
          $id('exportBtn').addEventListener('click', () => {
            this.showExportMenu();
          });
        },

        showExportMenu() {
          const formats = [
            { name: 'Text File (.txt)', value: 'txt' },
            { name: 'Markdown File (.md)', value: 'markdown' },
            { name: 'HTML File (.html)', value: 'html' },
            { name: 'LaTeX File (.tex)', value: 'latex' },
            { name: 'JSON File (.json)', value: 'json' },
            { name: 'CSV File (.csv)', value: 'csv' }
          ];

          const menu = formats.map(format =>
            `<button class="btn btn-text" onclick="OutputManager.exportAs('${format.value}')" style="width:100%;text-align:left;justify-content:flex-start">
                ${format.name}
            </button>`
          ).join('');

          UI.showToast(`<div style="display:flex;flex-direction:column;gap:var(--space-sm)">${menu}</div>`, 'info', 0);
        },

        exportAs(format) {
          const output = $id('outputText').value;
          if (!output.trim()) {
            UI.showToast('No output to export', 'warning');
            return;
          }

          let blob, filename, mimeType;

          switch (format) {
            case 'txt':
              blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
              filename = `ai-formatter-output-${new Date().toISOString().slice(0, 10)}.txt`;
              break;
            case 'markdown':
              const mdContent = this.convertToMarkdown(output);
              blob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8' });
              filename = `ai-formatter-output-${new Date().toISOString().slice(0, 10)}.md`;
              break;
            case 'html':
              const htmlContent = this.convertToHTML(output);
              blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
              filename = `ai-formatter-output-${new Date().toISOString().slice(0, 10)}.html`;
              break;
            case 'latex':
              const latexContent = this.convertToLaTeX(output);
              blob = new Blob([latexContent], { type: 'text/plain;charset=utf-8' });
              filename = `ai-formatter-output-${new Date().toISOString().slice(0, 10)}.tex`;
              break;
            case 'csv':
              let csvContent = output;
              if (output.includes('\t') || (output.includes('  ') && output.split('\n').length > 1)) {
                csvContent = output.split('\n').map(row => {
                  return row.replace(/\s{2,}/g, '\t').replace(/\t/g, ',');
                }).join('\n');
              }
              blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
              filename = `ai-formatter-output-${new Date().toISOString().slice(0, 10)}.csv`;
              break;
            case 'json':
              const data = {
                input: $id('textInput').value,
                prompt: $id('customPrompt').value,
                output: output,
                timestamp: new Date().toISOString(),
                provider: State.settings.provider,
                format: State.outputFormat
              };
              blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
              filename = `ai-formatter-results-${new Date().toISOString().slice(0, 10)}.json`;
              break;
            default:
              UI.showToast('Unsupported export format', 'error');
              return;
          }

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          UI.showToast(`Exported as ${format.toUpperCase()}`, 'success');
        }
      };

      // ========================================
      // Keyboard Shortcuts Manager
      // ========================================
      const ShortcutsManager = {
        init() {
          this.bindShortcuts();
        },

        bindShortcuts() {
          document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when user is typing in inputs
            if (e.target.matches('textarea, input, select')) return;

            const ctrlKey = e.ctrlKey || e.metaKey; // Support both Ctrl and Cmd

            if (ctrlKey && e.key === 'Enter') {
              e.preventDefault();
              App.processText();
            } else if (ctrlKey && e.shiftKey && e.key === 'C') {
              e.preventDefault();
              $id('copyBtn').click();
            } else if (ctrlKey && e.key === '1') {
              e.preventDefault();
              $id('textInput').focus();
            } else if (ctrlKey && e.key === '2') {
              e.preventDefault();
              $id('outputText').focus();
            } else if (ctrlKey && e.key === 'U') {
              e.preventDefault();
              $id('fileInput').click();
            } else if (ctrlKey && e.key === 'T') {
              e.preventDefault();
              UI.toggleTheme();
            } else if (e.key === '?') {
              e.preventDefault();
              $id('shortcutsModal').classList.add('active');
            } else if (e.key === 'Escape') {
              // Close all modals
              $all('.modal').forEach(modal => modal.classList.remove('active'));
            }
            else if (ctrlKey && e.key === '/') {
              e.preventDefault();
              $id('chatBtn').click();
            }
          });
        }
      };

      // ========================================
      // Prompts Manager - Enhanced
      // ========================================
      const Prompts = {
        templates: {
          reflow: 'Fix spacing, dehyphenate words, merge broken lines, preserve bullets and tables. Do not summarize or change wording. Output only cleaned text.',
          'list-to-csv': 'Convert line-separated items into a single-line comma-separated list. Keep original order. Output only the list.',
          'fix-table': 'Detect and preserve table-like rows with columns separated by tabs. Fix broken cells and align columns. Output only the reformatted table.',
          'clean-email': 'Remove email headers, quotes, and formatting artifacts. Keep only the main message content. Output clean paragraphs.',
          'markdown': 'Convert to clean Markdown format with proper headings, lists, emphasis, and code blocks.',
          'html': 'Convert to semantic HTML with proper tags for paragraphs, headings, lists, and tables.',
          'latex': 'Convert to LaTeX format with proper document structure and mathematical notation.'
        },

        load() {
          State.savedPrompts = Storage.load('ai_formatter_prompts', []);
          this.render();
        },

        save(name, prompt) {
          const id = Math.random().toString(36).slice(2, 10);
          State.savedPrompts.push({ id, name, prompt, created: Date.now() });
          Storage.save('ai_formatter_prompts', State.savedPrompts);
          this.render();
          UI.showToast('Prompt saved successfully', 'success');
        },

        delete(id) {
          State.savedPrompts = State.savedPrompts.filter(p => p.id !== id);
          Storage.save('ai_formatter_prompts', State.savedPrompts);
          this.render();
          UI.showToast('Prompt deleted', 'info');
        },

        render() {
          const container = $id('savedPromptsList');
          const section = $id('savedPromptsSection');

          if (State.savedPrompts.length === 0) {
            section.style.display = 'none';
            return;
          }

          section.style.display = 'block';
          container.innerHTML = '';

          State.savedPrompts.forEach(p => {
            const chip = document.createElement('button');
            chip.className = 'prompt-chip';
            chip.setAttribute('role', 'listitem');
            chip.innerHTML = `
                <span>${this.escapeHtml(p.name)}</span>
                <span class="material-icons" style="font-size:14px;opacity:0.7" aria-label="Delete prompt">close</span>
            `;

            chip.addEventListener('click', (e) => {
              if (e.target.classList.contains('material-icons')) {
                e.stopPropagation();
                if (confirm(`Delete prompt "${p.name}"?`)) {
                  this.delete(p.id);
                }
              } else {
                $id('customPrompt').value = p.prompt;
                $id('promptSelect').value = 'custom';
                UI.showToast(`Loaded prompt: ${p.name}`, 'info');
              }
            });

            container.appendChild(chip);
          });
        },

        apply(key) {
          if (this.templates[key]) {
            $id('customPrompt').value = this.templates[key];
            $id('promptSelect').value = key;

            // Update active state of prompt chips
            $all('.prompt-chip').forEach(chip => {
              chip.classList.remove('active');
              chip.setAttribute('aria-pressed', 'false');
            });

            const activeChip = document.querySelector(`.prompt-chip[data-prompt="${key}"]`);
            if (activeChip) {
              activeChip.classList.add('active');
              activeChip.setAttribute('aria-pressed', 'true');
            }
          }
        },

        suggestPrompt() {
          const text = $id('textInput').value;
          if (!text || text.length < 10) {
            UI.showToast('Please enter some text to get prompt suggestions', 'warning');
            return;
          }

          const analysis = ContentAnalyzer.analyze(text);
          if (analysis && analysis.suggestions.length > 0) {
            const suggestion = analysis.suggestions[0];
            this.apply(suggestion);
            UI.showToast(`Applied suggested prompt: ${suggestion}`, 'info');
          } else {
            UI.showToast('No specific suggestions available. Try the "Reflow text" prompt.', 'info');
          }
        },

        escapeHtml(unsafe) {
          return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        }
      };

      // ========================================
      // Settings Manager - Enhanced
      // ========================================
      const Settings = {
        load() {
          const saved = Storage.load('ai_formatter_settings', {});
          
          // Auto-configure for deployment if no settings exist
          if (Object.keys(saved).length === 0) {
            console.log('No saved settings found, configuring for deployment...');
            const defaultSettings = {
              provider: 'local',
              apiKey: '',
              model: '',
              customUrl: '',
              customHeader: 'Authorization',
              saveKey: false,
              autoProcess: true
            };
            
            // Save the default settings
            Storage.save('ai_formatter_settings', defaultSettings);
            State.settings = defaultSettings;
            
            // Show helpful message to user
            setTimeout(() => {
              UI.showToast('Welcome! Using local processing mode. Configure AI providers in Settings for enhanced features.', 'info', 6000);
            }, 1000);
          } else {
            // Use existing saved settings
            State.settings = {
              provider: saved.provider || '',
              apiKey: saved.saveKey ? (saved.apiKey || '') : '',
              model: saved.model || '',
              customUrl: saved.customUrl || '',
              customHeader: saved.customHeader || 'Authorization',
              saveKey: saved.saveKey || false,
              autoProcess: saved.autoProcess !== undefined ? saved.autoProcess : true
            };
          }
      
          this.updateUI();
        },
      
        save() {
          const settings = {
            provider: $id('providerSelect').value,
            apiKey: State.settings.saveKey ? $id('apiKeyInput').value.trim() : '',
            model: $id('modelInput').value.trim(),
            customUrl: $id('customUrl')?.value.trim() || '',
            customHeader: $id('customHeader')?.value.trim() || 'Authorization',
            saveKey: $id('saveKeyCheck').checked,
            autoProcess: true
          };
      
          State.settings = settings;
          if (Storage.save('ai_formatter_settings', settings)) {
            UI.showToast('Settings saved successfully', 'success');
            $id('settingsModal').classList.remove('active');
          }
        },
      
        clear() {
          if (!confirm('Clear all saved settings and API keys?')) return;
      
          Storage.remove('ai_formatter_settings');
          
          // Reset to deployment defaults
          const defaultSettings = {
            provider: 'local',
            apiKey: '',
            model: '',
            customUrl: '',
            customHeader: 'Authorization',
            saveKey: false,
            autoProcess: true
          };
          
          State.settings = defaultSettings;
          Storage.save('ai_formatter_settings', defaultSettings);
      
          this.updateUI();
          UI.showToast('Settings reset to defaults', 'info');
        },
      
        updateUI() {
          $id('providerSelect').value = State.settings.provider || '';
          $id('apiKeyInput').value = State.settings.apiKey || '';
          $id('modelInput').value = State.settings.model || '';
          if ($id('customUrl')) $id('customUrl').value = State.settings.customUrl || '';
          if ($id('customHeader')) $id('customHeader').value = State.settings.customHeader || 'Authorization';
          $id('saveKeyCheck').checked = State.settings.saveKey || false;
      
          this.updateProviderUI();
        },
      
        updateProviderUI() {
          const provider = $id('providerSelect').value;
          const apiKeySection = $id('apiKeySection');
          const customSection = $id('customEndpointSection');
      
          if (provider === 'local' || !provider) {
            apiKeySection.style.display = 'none';
            if (customSection) customSection.style.display = 'none';
          } else if (provider === 'custom') {
            apiKeySection.style.display = 'block';
            if (customSection) customSection.style.display = 'block';
          } else {
            apiKeySection.style.display = 'block';
            if (customSection) customSection.style.display = 'none';
          }
        }
      };

        save() {
          const settings = {
            provider: $id('providerSelect').value,
            apiKey: State.settings.saveKey ? $id('apiKeyInput').value.trim() : '',
            model: $id('modelInput').value.trim(),
            customUrl: $id('customUrl')?.value.trim() || '',
            customHeader: $id('customHeader')?.value.trim() || 'Authorization',
            saveKey: $id('saveKeyCheck').checked,
            autoProcess: true // Always auto-process files
          };

          State.settings = settings;
          if (Storage.save('ai_formatter_settings', settings)) {
            UI.showToast('Settings saved successfully', 'success');
            $id('settingsModal').classList.remove('active');
          }
        },

        clear() {
          if (!confirm('Clear all saved settings and API keys?')) return;

          Storage.remove('ai_formatter_settings');
          State.settings = {
            provider: '',
            apiKey: '',
            model: '',
            customUrl: '',
            customHeader: 'Authorization',
            saveKey: false,
            autoProcess: true
          };

          this.updateUI();
          UI.showToast('Settings cleared', 'info');
        },

        updateUI() {
          $id('providerSelect').value = State.settings.provider || '';
          $id('apiKeyInput').value = State.settings.apiKey || '';
          $id('modelInput').value = State.settings.model || '';
          if ($id('customUrl')) $id('customUrl').value = State.settings.customUrl || '';
          if ($id('customHeader')) $id('customHeader').value = State.settings.customHeader || 'Authorization';
          $id('saveKeyCheck').checked = State.settings.saveKey || false;

          this.updateProviderUI();
        },

        updateProviderUI() {
          const provider = $id('providerSelect').value;
          const apiKeySection = $id('apiKeySection');
          const customSection = $id('customEndpointSection');

          if (provider === 'local' || !provider) {
            apiKeySection.style.display = 'none';
            if (customSection) customSection.style.display = 'none';
          } else if (provider === 'custom') {
            apiKeySection.style.display = 'block';
            if (customSection) customSection.style.display = 'block';
          } else {
            apiKeySection.style.display = 'block';
            if (customSection) customSection.style.display = 'none';
          }
        }
      };

      // ========================================
      // Main App Controller - Enhanced
      // ========================================
      const App = {
        async init() {
          console.log('AI Formatter Pro initializing...');

          // Initialize theme
          UI.initTheme();

          // Load settings and prompts
          Settings.load();
          Prompts.load();

          // Initialize chat
          ChatManager.init();

          // Initialize modules
          TemplateLibrary.init();
          OutputManager.init();
          ShortcutsManager.init();
          FileHandler.setupBatchProcessing();

          // Initialize OCR in background
          setTimeout(() => {
            OCRService.init().catch((error) => {
              console.warn('OCR initialization failed:', error);
              UI.showToast('OCR engine failed to initialize. Image processing will not be available.', 'warning');
            });
          }, 1000);

          this.bindEvents();

          // Set initial state
          UI.setStatus('Ready', 'ready');
          UI.setProgress(0);

          // Set up file drop with enhanced feedback
          const textInputWithUpload = document.querySelector('.text-input-with-upload');
          UI.setupFileDrop(textInputWithUpload, (files) => {
            FileHandler.handle(files);
          });

          console.log('App ready');
        },

        bindEvents() {
          // Enhanced file upload with immediate processing
          const uploadIconBtn = $id('uploadIconBtn');
          const fileInput = $id('fileInput');

          uploadIconBtn.addEventListener('click', () => fileInput.click());
          fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
              FileHandler.handle(Array.from(e.target.files));
              // Clear the input so the same file can be uploaded again
              e.target.value = '';
            }
          });

          // Text input content analysis
          $id('textInput').addEventListener('input', (e) => {
            ContentAnalyzer.updateAnalysisDisplay(e.target.value);
          });

          // Paste images and files
          $id('textInput').addEventListener('paste', async (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
              if (item.kind === 'file') {
                e.preventDefault();
                const file = item.getAsFile();
                if (file) {
                  await FileHandler.handle([file]);
                }
              }
            }
          });

          // Prompt selection
          $id('promptSelect').addEventListener('change', (e) => {
            const value = e.target.value;
            if (value === 'custom') {
              $id('customPrompt').value = '';
              $id('customPrompt').focus();
            } else if (value) {
              Prompts.apply(value);
            }
          });

          // Prompt chips
          $all('.prompt-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              const prompt = chip.dataset.prompt;
              Prompts.apply(prompt);
            });
          });

          // Save prompt
          $id('savePromptBtn').addEventListener('click', () => {
            const prompt = $id('customPrompt').value.trim();
            if (!prompt) {
              UI.showToast('Please enter a prompt to save', 'warning');
              return;
            }

            const name = prompt('Enter a name for this prompt:', 'Custom Prompt');
            if (name) {
              Prompts.save(name, prompt);
            }
          });

          // Test prompt
          $id('testPromptBtn').addEventListener('click', () => {
            const prompt = $id('customPrompt').value.trim();
            if (!prompt) {
              UI.showToast('Please enter a prompt to test', 'warning');
              return;
            }

            const testText = 'This is a sample text for testing the prompt. It has multiple sentences. And some formatting.';
            $id('textInput').value = testText;
            UI.showToast('Test text added. Click "Process with AI" to see results.', 'info');
          });

          // Suggest prompt
          $id('suggestPromptBtn').addEventListener('click', () => {
            Prompts.suggestPrompt();
          });

          // Process button
          $id('processBtn').addEventListener('click', async () => {
            await this.processText();
          });

          // Output actions
          $id('copyBtn').addEventListener('click', () => {
            const output = $id('outputText').value;
            if (!output.trim()) {
              UI.showToast('No output to copy', 'warning');
              return;
            }

            navigator.clipboard.writeText(output).then(() => {
              UI.showToast('Output copied to clipboard', 'success');
            }).catch(() => {
              // Fallback for older browsers
              $id('outputText').select();
              document.execCommand('copy');
              UI.showToast('Output copied to clipboard', 'success');
            });
          });

          $id('clearOutputBtn').addEventListener('click', () => {
            $id('outputText').value = '';
            $id('outputPreview').style.display = 'none';
            UI.showToast('Output cleared', 'info');
          });

          $id('reprocessBtn').addEventListener('click', () => {
            const output = $id('outputText').value;
            if (!output.trim()) {
              UI.showToast('No output to reprocess', 'warning');
              return;
            }

            $id('textInput').value = output;
            $id('outputText').value = '';
            $id('outputPreview').style.display = 'none';
            UI.showToast('Output moved to input for reprocessing', 'info');
          });

          // Clear library
          $id('clearLibraryBtn').addEventListener('click', () => {
            FileHandler.clearLibrary();
          });

          // Theme toggle
          $id('themeToggle').addEventListener('click', () => {
            UI.toggleTheme();
          });

          // Settings
          $id('providerSelect').addEventListener('change', () => {
            Settings.updateProviderUI();
          });

          $id('toggleKeyBtn').addEventListener('click', () => {
            const input = $id('apiKeyInput');
            const icon = $id('toggleKeyBtn').querySelector('.material-icons');
            if (input.type === 'password') {
              input.type = 'text';
              icon.textContent = 'visibility_off';
              icon.setAttribute('aria-label', 'Hide API key');
            } else {
              input.type = 'password';
              icon.textContent = 'visibility';
              icon.setAttribute('aria-label', 'Show API key');
            }
          });

          $id('testKeyBtn').addEventListener('click', async () => {
            const btn = $id('testKeyBtn');
            UI.showLoading(btn, true, 'Testing...');

            try {
              State.settings.provider = $id('providerSelect').value;
              State.settings.apiKey = $id('apiKeyInput').value.trim();
              State.settings.model = $id('modelInput').value.trim();

              await AIService.testConnection();
              UI.showToast('API key works! Connection successful.', 'success');
            } catch (error) {
              UI.showToast(`API test failed: ${error.message}`, 'error');
            } finally {
              UI.showLoading(btn, false);
            }
          });

          $id('saveSettingsBtn').addEventListener('click', () => Settings.save());
          $id('clearSettingsBtn').addEventListener('click', () => Settings.clear());

          // Modals
          $id('helpBtn').addEventListener('click', () => {
            $id('helpModal').classList.add('active');
            $id('helpModal').setAttribute('aria-hidden', 'false');
          });

          $id('helpCloseBtn').addEventListener('click', () => {
            $id('helpModal').classList.remove('active');
            $id('helpModal').setAttribute('aria-hidden', 'true');
          });

          $id('helpModal').addEventListener('click', (e) => {
            if (e.target === $id('helpModal')) {
              $id('helpModal').classList.remove('active');
              $id('helpModal').setAttribute('aria-hidden', 'true');
            }
          });

          $id('settingsBtn').addEventListener('click', () => {
            $id('settingsModal').classList.add('active');
            $id('settingsModal').setAttribute('aria-hidden', 'false');
          });

          $id('settingsCloseBtn').addEventListener('click', () => {
            $id('settingsModal').classList.remove('active');
            $id('settingsModal').setAttribute('aria-hidden', 'true');
          });

          $id('settingsModal').addEventListener('click', (e) => {
            if (e.target === $id('settingsModal')) {
              $id('settingsModal').classList.remove('active');
              $id('settingsModal').setAttribute('aria-hidden', 'true');
            }
          });

          // Shortcuts modal
          $id('shortcutsBtn').addEventListener('click', () => {
            $id('shortcutsModal').classList.add('active');
            $id('shortcutsModal').setAttribute('aria-hidden', 'false');
          });

          $id('shortcutsCloseBtn').addEventListener('click', () => {
            $id('shortcutsModal').classList.remove('active');
            $id('shortcutsModal').setAttribute('aria-hidden', 'true');
          });

          $id('shortcutsModal').addEventListener('click', (e) => {
            if (e.target === $id('shortcutsModal')) {
              $id('shortcutsModal').classList.remove('active');
              $id('shortcutsModal').setAttribute('aria-hidden', 'true');
            }
          });

          // Templates modal
          $id('templatesBtn').addEventListener('click', () => {
            $id('templatesModal').classList.add('active');
            $id('templatesModal').setAttribute('aria-hidden', 'false');
          });

          $id('templatesCloseBtn').addEventListener('click', () => {
            $id('templatesModal').classList.remove('active');
            $id('templatesModal').setAttribute('aria-hidden', 'true');
          });

          $id('templatesModal').addEventListener('click', (e) => {
            if (e.target === $id('templatesModal')) {
              $id('templatesModal').classList.remove('active');
              $id('templatesModal').setAttribute('aria-hidden', 'true');
            }
          });

          // Handle page visibility changes
          document.addEventListener('visibilitychange', () => {
            if (document.hidden && State.processing) {
              UI.showToast('Processing continues in background', 'info');
            }
          });

          // Cleanup on page unload
          window.addEventListener('beforeunload', () => {
            OCRService.cleanup();
          });
        },

        async processText() {
          if (State.processing) {
            UI.showToast('Already processing, please wait...', 'warning');
            return;
          }

          const inputText = $id('textInput').value.trim();
          const prompt = $id('customPrompt').value.trim();

          if (!inputText) {
            UI.showToast('Please enter text or upload a document', 'warning');
            return;
          }

          if (!prompt) {
            UI.showToast('Please select or enter a formatting prompt', 'warning');
            return;
          }

          State.processing = true;
          const btn = $id('processBtn');
          UI.showLoading(btn);
          UI.setStatus('Processing...', 'processing');
          UI.setProgress(5);

          try {
            const result = await AIService.callProvider(prompt, inputText, State.outputFormat);

            $id('outputText').value = result;

            UI.setProgress(100);
            UI.setStatus('Complete', 'ready');
            UI.showToast('Processing completed successfully', 'success');

            // Show confetti for successful processing
            if (result.length > 10) {
              UI.showConfetti();
            }

            setTimeout(() => {
              UI.setProgress(0);
              UI.setStatus('Ready', 'ready');
            }, 2000);
          } catch (error) {
            console.error('Processing error:', error);
            UI.setProgress(0);
            UI.setStatus('Failed', 'error');
            UI.showToast(`Processing failed: ${error.message}`, 'error');
          } finally {
            UI.showLoading(btn, false);
            State.processing = false;
          }
        }
      };

      // Chat Manager
        const ChatManager = {
          init() {
            this.bindEvents();
            this.loadChatHistory();
          },

          bindEvents() {
            // Chat modal
            $id('chatBtn').addEventListener('click', () => {
              $id('chatModal').classList.add('active');
              $id('chatInput').focus();
            });

            $id('chatCloseBtn').addEventListener('click', () => {
              $id('chatModal').classList.remove('active');
            });

            $id('chatModal').addEventListener('click', (e) => {
              if (e.target === $id('chatModal')) {
                $id('chatModal').classList.remove('active');
              }
            });

            // Send message
            $id('sendChatBtn').addEventListener('click', () => {
              this.sendMessage();
            });

            $id('chatInput').addEventListener('keydown', (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
              }
            });

            // Clear chat
            $id('clearChatBtn').addEventListener('click', () => {
              if (confirm('Clear entire chat history?')) {
                this.clearChat();
              }
            });

            // Use in input
            $id('useChatOutputBtn').addEventListener('click', () => {
              this.useLastResponseInInput();
            });

            // Export chat
            $id('exportChatBtn').addEventListener('click', () => {
              this.exportChat();
            });
          },

          async sendMessage() {
            const input = $id('chatInput');
            const message = input.value.trim();

            if (!message) {
              UI.showToast('Please enter a message', 'warning');
              return;
            }

            if (!State.settings.provider || State.settings.provider === 'local') {
              UI.showToast('Please configure an AI provider in Settings first', 'error');
              return;
            }

            // Add user message to chat
            this.addMessage(message, 'user');
            input.value = '';

            // Show thinking indicator
            this.showThinking();

            try {
              // Prepare chat context
              const chatContext = this.buildChatContext();

              const response = await AIService.callProvider(
                chatContext,
                message,
                'text'
              );

              // Remove thinking indicator and add AI response
              this.removeThinking();
              this.addMessage(response, 'ai');

              // Save to history
              this.saveChatHistory();

            } catch (error) {
              this.removeThinking();
              this.addMessage(`Sorry, I encountered an error: ${error.message}`, 'ai', true);
              console.error('Chat error:', error);
            }
          },

          buildChatContext() {
            return `You are a helpful AI assistant for a text formatting tool. The user is using AI Formatter Pro.

Please provide helpful, concise responses. You can:
- Answer questions about text formatting and processing
- Help create or refine formatting prompts
- Explain OCR and text extraction concepts
- Provide guidance on using the tool's features
- Help with general text processing tasks

Keep responses focused and practical. If the user asks about something outside text processing, politely redirect to your area of expertise.`;
          },

          addMessage(content, sender, isError = false) {
            const messagesContainer = $id('chatMessages');
            const messageDiv = document.createElement('div');

            messageDiv.className = `chat-message ${sender}-message`;
            if (isError) {
              messageDiv.style.background = 'var(--error-bg)';
              messageDiv.style.color = 'var(--error-text)';
              messageDiv.style.border = '1px solid var(--error)';
            }

            const timestamp = new Date().toLocaleTimeString([], {
              hour: '2-digit',
              minute: '2-digit'
            });

            messageDiv.innerHTML = `
            <div class="message-content">
                ${sender === 'ai' ? '<strong>AI Assistant:</strong> ' : ''}${this.formatMessage(content)}
            </div>
            <div class="message-time">${timestamp}</div>
        `;

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Add to state
            State.chatHistory.push({
              content,
              sender,
              timestamp: Date.now(),
              isError
            });
          },

          formatMessage(content) {
            // Simple formatting - you can enhance this
            return content
              .replace(/\n/g, '<br>')
              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.*?)\*/g, '<em>$1</em>')
              .replace(/`(.*?)`/g, '<code>$1</code>');
          },

          showThinking() {
            const messagesContainer = $id('chatMessages');
            const thinkingDiv = document.createElement('div');
            thinkingDiv.id = 'thinkingIndicator';
            thinkingDiv.className = 'chat-message ai-message chat-thinking';
            thinkingDiv.innerHTML = `
            <div class="message-content">
                <strong>AI Assistant:</strong> Thinking...
                <div class="spinner" style="display: inline-block; margin-left: var(--space-sm);"></div>
            </div>
        `;
            messagesContainer.appendChild(thinkingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          },

          removeThinking() {
            const thinkingDiv = $id('thinkingIndicator');
            if (thinkingDiv) {
              thinkingDiv.remove();
            }
          },

          clearChat() {
            State.chatHistory = [];
            $id('chatMessages').innerHTML = `
            <div class="chat-message ai-message">
                <div class="message-content">
                    <strong>AI Assistant:</strong> Hello! I'm here to help. You can ask me anything - questions about text formatting, help with prompts, or general assistance. What would you like to know?
                </div>
                <div class="message-time">Just now</div>
            </div>
        `;
            Storage.remove('ai_formatter_chat_history');
            UI.showToast('Chat cleared', 'info');
          },

          useLastResponseInInput() {
            const lastAiMessage = [...State.chatHistory].reverse().find(msg =>
              msg.sender === 'ai' && !msg.isError
            );

            if (lastAiMessage) {
              $id('textInput').value = lastAiMessage.content;
              $id('chatModal').classList.remove('active');
              UI.showToast('AI response copied to input area', 'success');
            } else {
              UI.showToast('No AI response found to use', 'warning');
            }
          },

          exportChat() {
            if (State.chatHistory.length === 0) {
              UI.showToast('No chat history to export', 'warning');
              return;
            }

            const chatText = State.chatHistory.map(msg =>
              `${msg.sender === 'user' ? 'You' : 'AI'}: ${msg.content}`
            ).join('\n\n');

            const blob = new Blob([chatText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-chat-${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            UI.showToast('Chat exported', 'success');
          },

          loadChatHistory() {
            State.chatHistory = Storage.load('ai_formatter_chat_history', []);

            // Restore messages if any
            if (State.chatHistory.length > 0) {
              $id('chatMessages').innerHTML = '';
              State.chatHistory.forEach(msg => {
                this.addMessage(msg.content, msg.sender, msg.isError);
              });
            }
          },

          saveChatHistory() {
            Storage.save('ai_formatter_chat_history', State.chatHistory);
          }
        };


      // ========================================
      // Initialize App
      // ========================================
      document.addEventListener('DOMContentLoaded', () => {
        App.init();
      });

      // Make utilities globally available for debugging
      window.App = App;
      window.State = State;
      window.FileHandler = FileHandler;

  </SCRipt>
</body>

</html>
